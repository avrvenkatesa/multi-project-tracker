Create issue matching algorithm for Phase 4 Mode 2

CONTEXT:
- Workstream detection complete âœ…
- Generated checklists ready for matching
- Need to intelligently match checklists to existing project issues
- Calculate confidence scores for each match
- Suggest new issues for unmatched checklists
- Working on branch: feature/phase4-mode2-smart-matching

TASK:
Build AI-powered matching service that pairs generated checklists with existing issues.

IMPLEMENTATION:

Part 1: Create Issue Matching Service

File: services/checklist-matcher.js
```javascript
// services/checklist-matcher.js
// Phase 4 Mode 2: Intelligent Checklist-to-Issue Matching

const openai = require('./ai-client'); // Use your existing OpenAI client

/**
 * Match generated checklists to existing project issues
 * @param {array} checklists - Generated checklists from workstreams
 * @param {number} projectId - Project ID
 * @returns {object} Matching results with confidence scores
 */
async function matchChecklistsToIssues(checklists, projectId, pool) {
  console.log(`ðŸ”— Matching ${checklists.length} checklists to project issues...`);
  
  try {
    // Get all issues in the project
    const issuesResult = await pool.query(
      `SELECT 
        id, 
        title, 
        description, 
        type, 
        priority, 
        status,
        tags
      FROM issues 
      WHERE project_id = $1 
      ORDER BY created_at DESC`,
      [projectId]
    );
    
    const issues = issuesResult.rows;
    
    if (issues.length === 0) {
      console.log('âš ï¸ No issues found in project - all checklists will be unmatched');
      return {
        matches: checklists.map(checklist => ({
          checklist: checklist,
          matchedIssue: null,
          confidence: 0,
          reasoning: 'No issues exist in this project',
          suggestedNewIssue: generateNewIssuesSuggestion(checklist)
        })),
        summary: {
          totalChecklists: checklists.length,
          matched: 0,
          unmatched: checklists.length,
          averageConfidence: 0
        }
      };
    }
    
    console.log(`ðŸ“‹ Found ${issues.length} issues in project`);
    
    // Match each checklist
    const matches = [];
    
    for (const checklist of checklists) {
      console.log(`  â†’ Matching: ${checklist.workstreamName}`);
      
      const match = await findBestMatch(checklist, issues);
      matches.push(match);
      
      if (match.matchedIssue) {
        console.log(`    âœ“ Matched to Issue #${match.matchedIssue.id} (${match.confidence}% confidence)`);
      } else {
        console.log(`    â—‹ No match found - suggest creating new issue`);
      }
    }
    
    // Calculate summary statistics
    const matchedCount = matches.filter(m => m.matchedIssue !== null).length;
    const totalConfidence = matches.reduce((sum, m) => sum + m.confidence, 0);
    const avgConfidence = matchedCount > 0 ? Math.round(totalConfidence / matches.length) : 0;
    
    console.log(`âœ… Matching complete: ${matchedCount}/${checklists.length} matched (${avgConfidence}% avg confidence)`);
    
    return {
      matches: matches,
      summary: {
        totalChecklists: checklists.length,
        matched: matchedCount,
        unmatched: checklists.length - matchedCount,
        averageConfidence: avgConfidence,
        highConfidence: matches.filter(m => m.confidence >= 80).length,
        mediumConfidence: matches.filter(m => m.confidence >= 50 && m.confidence < 80).length,
        lowConfidence: matches.filter(m => m.confidence < 50 && m.matchedIssue !== null).length
      }
    };
    
  } catch (error) {
    console.error('Error matching checklists:', error);
    throw error;
  }
}

/**
 * Find best matching issue for a checklist
 */
async function findBestMatch(checklist, issues) {
  try {
    // Build context for AI matching
    const checklistSummary = {
      name: checklist.workstreamName,
      description: checklist.workstreamDescription,
      phase: checklist.suggestedPhase,
      complexity: checklist.estimatedComplexity,
      itemCount: checklist.checklist.sections?.reduce(
        (sum, s) => sum + (s.items?.length || 0), 0
      ) || 0,
      sampleItems: extractSampleItems(checklist.checklist, 5)
    };
    
    const issuesSummary = issues.map(issue => ({
      id: issue.id,
      title: issue.title,
      description: issue.description?.substring(0, 200) || '',
      type: issue.type,
      priority: issue.priority,
      status: issue.status
    }));
    
    // Use AI to find best match
    const aiMatch = await analyzeMatchWithAI(checklistSummary, issuesSummary);
    
    // If high confidence match found, return it
    if (aiMatch.issueId && aiMatch.confidence >= 40) {
      const matchedIssue = issues.find(i => i.id === aiMatch.issueId);
      
      return {
        checklist: checklist,
        matchedIssue: matchedIssue,
        confidence: aiMatch.confidence,
        reasoning: aiMatch.reasoning,
        suggestedNewIssue: null
      };
    }
    
    // No good match - suggest creating new issue
    return {
      checklist: checklist,
      matchedIssue: null,
      confidence: 0,
      reasoning: aiMatch.reasoning || 'No suitable match found in existing issues',
      suggestedNewIssue: generateNewIssuesSuggestion(checklist)
    };
    
  } catch (error) {
    console.error(`Error finding match for ${checklist.workstreamName}:`, error);
    
    // Fallback: no match
    return {
      checklist: checklist,
      matchedIssue: null,
      confidence: 0,
      reasoning: `Error during matching: ${error.message}`,
      suggestedNewIssue: generateNewIssuesSuggestion(checklist)
    };
  }
}

/**
 * Use AI to analyze and find best match
 */
async function analyzeMatchWithAI(checklistSummary, issues) {
  const prompt = `You are an intelligent project management assistant. Match a checklist to the most appropriate existing issue.

CHECKLIST TO MATCH:
Name: ${checklistSummary.name}
Description: ${checklistSummary.description}
Phase: ${checklistSummary.phase}
Complexity: ${checklistSummary.complexity}
Items (${checklistSummary.itemCount}):
${checklistSummary.sampleItems.map((item, i) => `${i + 1}. ${item}`).join('\n')}

AVAILABLE ISSUES:
${issues.map((issue, i) => `
Issue ${i + 1}:
  ID: ${issue.id}
  Title: ${issue.title}
  Description: ${issue.description}
  Type: ${issue.type}
  Priority: ${issue.priority}
  Status: ${issue.status}
`).join('\n')}

TASK:
Analyze the checklist and determine which issue (if any) it best matches.

MATCHING CRITERIA:
1. Semantic similarity between checklist name/items and issue title/description
2. Alignment of work scope and deliverables
3. Phase or category matching
4. Avoid forcing matches - only match if there's genuine alignment

CONFIDENCE SCORING:
- 90-100%: Very strong match (nearly identical scope)
- 80-89%: Strong match (clear alignment, some differences)
- 70-79%: Good match (significant overlap)
- 60-69%: Moderate match (partial alignment)
- 50-59%: Weak match (some relevance)
- Below 50%: Not a good match (suggest new issue instead)

OUTPUT FORMAT (JSON):
{
  "issueId": 123 | null,
  "confidence": 85,
  "reasoning": "Detailed explanation of why this is the best match, or why no match was found. Be specific about what aligns or doesn't align."
}

CRITICAL:
- Return ONLY valid JSON (no markdown, no code blocks)
- If no issue is a good match (confidence would be <40%), return issueId: null
- Provide clear, specific reasoning
- Don't force low-quality matches

Analyze and return the JSON now.`;

  const response = await openai.chat.completions.create({
    model: 'gpt-4o',
    messages: [
      {
        role: 'system',
        content: 'You are an expert at analyzing project scope and matching work items to issues. You provide honest assessments and only suggest matches with genuine alignment.'
      },
      {
        role: 'user',
        content: prompt
      }
    ],
    temperature: 0.3, // Lower for more consistent matching
    max_tokens: 500
  });
  
  const rawResponse = response.choices[0].message.content;
  
  // Parse response
  let jsonText = rawResponse.trim();
  jsonText = jsonText.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
  
  const result = JSON.parse(jsonText);
  
  // Validate and normalize
  return {
    issueId: result.issueId || null,
    confidence: Math.min(100, Math.max(0, result.confidence || 0)),
    reasoning: result.reasoning || 'No reasoning provided'
  };
}

/**
 * Extract sample items from checklist for matching
 */
function extractSampleItems(checklist, count = 5) {
  const items = [];
  
  if (!checklist.sections || checklist.sections.length === 0) {
    return items;
  }
  
  for (const section of checklist.sections) {
    if (!section.items || section.items.length === 0) continue;
    
    for (const item of section.items) {
      items.push(item.text);
      if (items.length >= count) break;
    }
    if (items.length >= count) break;
  }
  
  return items;
}

/**
 * Generate suggestion for new issue based on checklist
 */
function generateNewIssuesSuggestion(checklist) {
  // Extract first few checklist items for description
  const items = extractSampleItems(checklist.checklist, 3);
  
  return {
    title: checklist.workstreamName,
    description: `${checklist.workstreamDescription}\n\nKey tasks:\n${items.map((item, i) => `${i + 1}. ${item}`).join('\n')}`,
    type: 'Task',
    priority: checklist.estimatedComplexity === 'high' ? 'high' : 'medium',
    suggestedPhase: checklist.suggestedPhase
  };
}

/**
 * Bulk operation: Create issues and link checklists
 * @param {array} approvedMatches - Matches approved by user
 * @param {number} projectId - Project ID
 * @param {number} userId - User creating items
 */
async function createMatchedChecklists(approvedMatches, projectId, userId, pool) {
  console.log(`ðŸ“¦ Creating ${approvedMatches.length} matched checklists...`);
  
  const results = {
    created: [],
    failed: [],
    issuesCreated: 0
  };
  
  const client = await pool.connect();
  
  try {
    await client.query('BEGIN');
    
    for (const match of approvedMatches) {
      try {
        let issueId = match.issueId;
        
        // Create new issue if requested
        if (match.createNewIssue && match.suggestedNewIssue) {
          const issueResult = await client.query(
            `INSERT INTO issues 
               (title, description, type, priority, status, project_id, created_by)
             VALUES ($1, $2, $3, $4, 'To Do', $5, $6)
             RETURNING id`,
            [
              match.suggestedNewIssue.title,
              match.suggestedNewIssue.description,
              match.suggestedNewIssue.type || 'Task',
              match.suggestedNewIssue.priority || 'medium',
              projectId,
              userId
            ]
          );
          
          issueId = issueResult.rows[0].id;
          results.issuesCreated++;
          
          console.log(`  âœ“ Created new issue #${issueId}: ${match.suggestedNewIssue.title}`);
        }
        
        // Create checklist
        const checklist = match.checklist.checklist;
        
        const checklistResult = await client.query(
          `INSERT INTO checklists 
             (title, description, project_id, related_issue_id, created_by, source_document)
           VALUES ($1, $2, $3, $4, $5, $6)
           RETURNING id`,
          [
            checklist.title,
            checklist.description,
            projectId,
            issueId,
            userId,
            'AI Generated from Document'
          ]
        );
        
        const checklistId = checklistResult.rows[0].id;
        
        // Create sections and items
        for (let i = 0; i < checklist.sections.length; i++) {
          const section = checklist.sections[i];
          
          const sectionResult = await client.query(
            `INSERT INTO checklist_sections (checklist_id, title, display_order)
             VALUES ($1, $2, $3)
             RETURNING id`,
            [checklistId, section.title, i]
          );
          
          const sectionId = sectionResult.rows[0].id;
          
          for (let j = 0; j < section.items.length; j++) {
            const item = section.items[j];
            await client.query(
              `INSERT INTO checklist_responses 
                 (section_id, item_text, notes, is_completed, display_order)
               VALUES ($1, $2, $3, FALSE, $4)`,
              [sectionId, item.text, item.notes || null, j]
            );
          }
        }
        
        results.created.push({
          checklistId: checklistId,
          issueId: issueId,
          workstreamName: match.checklist.workstreamName,
          newIssueCreated: match.createNewIssue || false
        });
        
        console.log(`  âœ“ Created checklist #${checklistId} for issue #${issueId}`);
        
      } catch (error) {
        console.error(`  âœ— Failed to create checklist for ${match.checklist.workstreamName}:`, error);
        results.failed.push({
          workstreamName: match.checklist.workstreamName,
          error: error.message
        });
      }
    }
    
    await client.query('COMMIT');
    
    console.log(`âœ… Batch creation complete: ${results.created.length} created, ${results.failed.length} failed`);
    
  } catch (error) {
    await client.query('ROLLBACK');
    console.error('Batch creation error:', error);
    throw error;
  } finally {
    client.release();
  }
  
  return results;
}

module.exports = {
  matchChecklistsToIssues,
  createMatchedChecklists
};
```

Part 2: Add API Endpoints

Add to server.js:
```javascript
// ============================================
// Phase 4 Mode 2: Issue Matching
// ============================================

const checklistMatcher = require('./services/checklist-matcher.js');

/**
 * Match generated checklists to existing issues
 * POST /api/projects/:projectId/match-checklists-to-issues
 * Body: { checklists: array }
 */
app.post('/api/projects/:projectId/match-checklists-to-issues', async (req, res) => {
  try {
    const { projectId } = req.params;
    const { checklists } = req.body;
    
    if (!checklists || !Array.isArray(checklists)) {
      return res.status(400).json({
        error: 'Checklists array required',
        message: 'Please provide checklists array in request body'
      });
    }
    
    console.log(`ðŸ”— Matching ${checklists.length} checklists to issues in project ${projectId}`);
    
    // Perform matching
    const results = await checklistMatcher.matchChecklistsToIssues(
      checklists,
      parseInt(projectId),
      pool
    );
    
    res.json({
      success: true,
      matches: results.matches,
      summary: results.summary
    });
    
  } catch (error) {
    console.error('Matching error:', error);
    res.status(500).json({
      error: 'Failed to match checklists',
      message: error.message
    });
  }
});

/**
 * Create matched checklists (batch operation)
 * POST /api/projects/:projectId/create-matched-checklists
 * Body: { approvedMatches: array }
 */
app.post('/api/projects/:projectId/create-matched-checklists', async (req, res) => {
  try {
    const { projectId } = req.params;
    const { approvedMatches } = req.body;
    const userId = req.user?.id || 1;
    
    if (!approvedMatches || !Array.isArray(approvedMatches)) {
      return res.status(400).json({
        error: 'Approved matches array required'
      });
    }
    
    console.log(`ðŸ“¦ Creating ${approvedMatches.length} matched checklists`);
    
    // Create checklists
    const results = await checklistMatcher.createMatchedChecklists(
      approvedMatches,
      parseInt(projectId),
      userId,
      pool
    );
    
    res.json({
      success: true,
      created: results.created.length,
      failed: results.failed.length,
      issuesCreated: results.issuesCreated,
      details: results
    });
    
  } catch (error) {
    console.error('Batch creation error:', error);
    res.status(500).json({
      error: 'Failed to create checklists',
      message: error.message
    });
  }
});
```

Part 3: Testing Script

Test the complete flow:
```javascript
// ==============================================
// Phase 4 Mode 2: Complete Flow Test
// ==============================================

async function testCompleteMode2Flow() {
  console.log('ðŸ§ª TESTING COMPLETE MODE 2 FLOW');
  console.log('================================\n');
  
  const projectId = 1; // Adjust to your project ID
  
  const testDoc = `
AZURE MIGRATION PROJECT

Phase 1: Infrastructure Assessment
Complete inventory and analysis of current infrastructure

Phase 2: Azure Setup  
Configure Azure environment and networking

Phase 3: Database Migration
Migrate databases to Azure SQL

Phase 4: Application Migration
Move applications to Azure VMs

Phase 5: Testing
Validate migration success
`;

  try {
    // STEP 1: Detect workstreams
    console.log('Step 1: Detecting workstreams...');
    const detectRes = await fetch(`/api/projects/${projectId}/analyze-workstreams`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      credentials: 'include',
      body: JSON.stringify({ documentText: testDoc, filename: 'test.txt' })
    });
    const workstreamsData = await detectRes.json();
    console.log(`âœ… ${workstreamsData.workstreams.length} workstreams detected\n`);
    
    // STEP 2: Generate checklists
    console.log('Step 2: Generating checklists...');
    const generateRes = await fetch(`/api/projects/${projectId}/generate-workstream-checklists`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      credentials: 'include',
      body: JSON.stringify({
        workstreams: workstreamsData.workstreams,
        documentText: testDoc
      })
    });
    const checklistsData = await generateRes.json();
    console.log(`âœ… ${checklistsData.count} checklists generated\n`);
    
    // STEP 3: Match to issues
    console.log('Step 3: Matching checklists to issues...');
    const matchRes = await fetch(`/api/projects/${projectId}/match-checklists-to-issues`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      credentials: 'include',
      body: JSON.stringify({
        checklists: checklistsData.checklists
      })
    });
    const matchData = await matchRes.json();
    
    console.log('âœ… MATCHING COMPLETE');
    console.log('-------------------');
    console.log('Summary:', matchData.summary);
    console.log('\nMatches:');
    matchData.matches.forEach((match, i) => {
      console.log(`\n${i + 1}. ${match.checklist.workstreamName}`);
      if (match.matchedIssue) {
        console.log(`   â†’ Issue #${match.matchedIssue.id}: ${match.matchedIssue.title}`);
        console.log(`   â†’ Confidence: ${match.confidence}%`);
        console.log(`   â†’ Reasoning: ${match.reasoning}`);
      } else {
        console.log(`   â†’ No match found`);
        console.log(`   â†’ Suggest: Create "${match.suggestedNewIssue.title}"`);
      }
    });
    
    console.log('\n\nâœ… TEST COMPLETE!');
    
    return matchData;
    
  } catch (error) {
    console.error('âŒ TEST FAILED:', error);
  }
}

// Run test
testCompleteMode2Flow();
```

VALIDATION CHECKLIST:

After implementation, verify:
- [ ] Service file created: services/checklist-matcher.js
- [ ] Two API endpoints added to server.js
- [ ] Matching returns confidence scores (0-100)
- [ ] High confidence matches (>80%) identified
- [ ] Unmatched checklists have new issue suggestions
- [ ] Reasoning provided for each match
- [ ] Summary statistics calculated
- [ ] Batch creation works
- [ ] New issues created when requested
- [ ] Checklists linked correctly

COMMIT MESSAGE:
"feat(phase4-mode2): add intelligent issue matching algorithm

- Create checklist-matcher.js with AI-powered matching
- Calculate confidence scores (0-100%) for each match
- Use semantic analysis for issue-checklist alignment
- Suggest new issue creation for unmatched checklists
- POST /api/projects/:id/match-checklists-to-issues
- POST /api/projects/:id/create-matched-checklists
- Batch operations with transaction support
- Summary statistics (matched/unmatched/confidence)
- Comprehensive error handling

Part 2/3 of Phase 4 Mode 2: Multi-Checklist Smart Matching"
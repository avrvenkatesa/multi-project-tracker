CONTEXT:
Phase 2a of Checklist System - Core AI features. Phase 1 complete with:
- 7 database tables (templates, sections, items, checklists, responses, comments, signoffs)
- 6 CRUD API endpoints functional
- Access Verification template seeded (303 items)
- Full UI for creating and filling checklists

TASK:
Implement AI-powered checklist generation from BOTH issues and action items using a hybrid template approach. AI-generated templates are marked as non-reusable by default (hidden from main template list) but can be promoted to reusable templates if users find them valuable.

ESTIMATED TIME: 6-8 hours

---

## REQUIREMENTS

### 1. Database Schema Updates

**Run these SQL migrations:**
```sql
-- Add flags to support hybrid template approach
ALTER TABLE checklist_templates 
ADD COLUMN is_reusable BOOLEAN DEFAULT true;

ALTER TABLE checklists 
ADD COLUMN is_ai_generated BOOLEAN DEFAULT false,
ADD COLUMN generation_source VARCHAR(50); -- 'issue' or 'action-item'

-- Update existing templates to be reusable
UPDATE checklist_templates SET is_reusable = true WHERE is_reusable IS NULL;

-- Add index for filtering non-reusable templates
CREATE INDEX idx_templates_reusable ON checklist_templates(is_reusable);

-- Add comment to explain the columns
COMMENT ON COLUMN checklist_templates.is_reusable IS 'True for user-created/system templates. False for AI-generated one-off templates that are hidden by default.';
COMMENT ON COLUMN checklists.is_ai_generated IS 'True if this checklist was generated by AI';
COMMENT ON COLUMN checklists.generation_source IS 'Source of AI generation: issue, action-item, or document';
2. Environment Variables
Add to .env file:
env# Choose ONE AI provider
OPENAI_API_KEY=your_openai_key_here
# OR
ANTHROPIC_API_KEY=your_claude_key_here

# AI Configuration
AI_PROVIDER=openai  # or 'anthropic'
AI_MODEL=gpt-4o
AI_MAX_TOKENS=2000
AI_TIMEOUT=30000
Install Dependencies:
bashnpm install openai @anthropic-ai/sdk
3. Backend Implementation
Create new file: server/ai-service.js
javascriptconst OpenAI = require('openai');
const Anthropic = require('@anthropic-ai/sdk');

const AI_PROVIDER = process.env.AI_PROVIDER || 'openai';

// Initialize AI client
let aiClient;
if (AI_PROVIDER === 'openai') {
  aiClient = new OpenAI({
    apiKey: process.env.OPENAI_API_KEY
  });
} else if (AI_PROVIDER === 'anthropic') {
  aiClient = new Anthropic({
    apiKey: process.env.ANTHROPIC_API_KEY
  });
}

/**
 * Generate checklist from issue
 */
async function generateChecklistFromIssue(issue) {
  const prompt = `You are a project management expert. Analyze this issue and generate a detailed checklist to address it.

Issue Title: ${issue.title}
Issue Description: ${issue.description || 'No description provided'}
Issue Type: ${issue.type || 'Unknown'}
Priority: ${issue.priority || 'Medium'}
Status: ${issue.status || 'Open'}
Labels: ${issue.labels || 'None'}

Based on this issue, generate a comprehensive checklist with:
1. A descriptive checklist title that clearly indicates the purpose
2. 3-7 main sections (logical groupings of related tasks)
3. 5-15 checklist items per section
4. Appropriate field types for each item
5. Mark critical items as required

For field types, use:
- "checkbox" for yes/no confirmations and completion checks
- "text" for short answers (names, IDs, hostnames, single values)
- "textarea" for detailed notes, descriptions, or long-form content
- "date" for dates, deadlines, and timestamps
- "radio" for multiple choice selections (include 2-5 options in field_options array)

IMPORTANT TEMPLATE MATCHING:
- If this issue is about verifying server access, checking credentials, or validating permissions/connectivity, set use_template=true and template_id=1 (Access Verification Checklist)
- Otherwise, generate a custom checklist structure with use_template=false and template_id=null

Respond ONLY with valid JSON in this exact format (no markdown, no code blocks):
{
  "title": "Clear, action-oriented checklist title",
  "description": "Brief description of checklist purpose and scope",
  "use_template": true or false,
  "template_id": 1 or null,
  "confidence": 75,
  "sections": [
    {
      "title": "Section name (e.g., 'Initial Setup', 'Validation Steps')",
      "description": "Brief description of this section's purpose",
      "items": [
        {
          "text": "Clear, actionable item description",
          "field_type": "checkbox|text|textarea|date|radio",
          "field_options": ["Option 1", "Option 2", "Option 3"] or null,
          "is_required": true or false,
          "help_text": "Optional guidance for completing this item"
        }
      ]
    }
  ],
  "reasoning": "1-2 sentence explanation of why this checklist structure was chosen"
}

Requirements:
- Minimum 20 total items across all sections
- At least 3 sections
- Mix of field types (not all checkboxes)
- Specific and actionable items
- Professional language`;

  return await callAI(prompt, 'issue');
}

/**
 * Generate checklist from action item
 */
async function generateChecklistFromActionItem(actionItem) {
  const prompt = `You are a project management expert. Analyze this action item and generate a detailed checklist to complete it.

Action Title: ${actionItem.title}
Description: ${actionItem.description || 'No description provided'}
Priority: ${actionItem.priority || 'Medium'}
Status: ${actionItem.status || 'Open'}
Due Date: ${actionItem.due_date || 'Not set'}
Assigned To: ${actionItem.assigned_to_name || 'Unassigned'}

Based on this action item, generate a comprehensive checklist that breaks down this action into concrete, executable steps:

1. A descriptive checklist title
2. 2-5 main sections representing major phases or categories of work
3. 3-10 specific, actionable items per section
4. Appropriate field types for each item
5. Mark critical items as required

For field types, use:
- "checkbox" for completion checks and confirmations
- "text" for capturing specific values, names, or identifiers
- "textarea" for notes, observations, or detailed responses
- "date" for deadlines, completion dates, or timestamps
- "radio" for selecting between predefined options

Think about:
- What are the prerequisite steps?
- What are the main execution steps?
- What validation/verification is needed?
- What documentation or follow-up is required?

Respond ONLY with valid JSON (no markdown formatting):
{
  "title": "Action-oriented checklist title",
  "description": "Brief description of how this checklist helps complete the action",
  "use_template": false,
  "template_id": null,
  "confidence": 80,
  "sections": [
    {
      "title": "Section name",
      "description": "What this section accomplishes",
      "items": [
        {
          "text": "Specific, actionable task description",
          "field_type": "checkbox|text|textarea|date|radio",
          "field_options": ["Option A", "Option B"] or null,
          "is_required": true or false,
          "help_text": "How to complete this step"
        }
      ]
    }
  ],
  "reasoning": "Why this breakdown makes sense for completing the action"
}

Requirements:
- Minimum 10 total items
- At least 2 sections
- Concrete, actionable steps
- Logical sequence`;

  return await callAI(prompt, 'action-item');
}

/**
 * Call AI with prompt and parse response
 */
async function callAI(prompt, sourceType) {
  try {
    let response;
    
    if (AI_PROVIDER === 'openai') {
      const completion = await aiClient.chat.completions.create({
        model: process.env.AI_MODEL || 'gpt-4o',
        messages: [
          { 
            role: 'system', 
            content: 'You are a project management expert who creates detailed, actionable checklists. Always respond with valid JSON only, no markdown formatting, no code blocks.' 
          },
          { role: 'user', content: prompt }
        ],
        temperature: 0.7,
        max_tokens: parseInt(process.env.AI_MAX_TOKENS) || 2000
      });
      
      response = completion.choices[0].message.content;
      
    } else if (AI_PROVIDER === 'anthropic') {
      const message = await aiClient.messages.create({
        model: 'claude-3-5-sonnet-20241022',
        max_tokens: parseInt(process.env.AI_MAX_TOKENS) || 2000,
        messages: [
          { 
            role: 'user', 
            content: `${prompt}\n\nIMPORTANT: Respond with ONLY valid JSON. No markdown code blocks, no explanations before or after.` 
          }
        ]
      });
      
      response = message.content[0].text;
    }
    
    // Clean response - remove markdown code blocks if AI included them
    response = response.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
    
    // Parse JSON
    const checklistData = JSON.parse(response);
    
    // Validate structure
    if (!checklistData.title || !checklistData.sections || !Array.isArray(checklistData.sections)) {
      throw new Error('Invalid checklist structure from AI');
    }
    
    // Validate sections have items
    if (checklistData.sections.length === 0 || !checklistData.sections[0].items) {
      throw new Error('Checklist must have sections with items');
    }
    
    // Add metadata
    checklistData.generation_source = sourceType;
    
    return checklistData;
    
  } catch (error) {
    console.error('AI generation error:', error);
    
    // Check if it's a parsing error
    if (error instanceof SyntaxError) {
      throw new Error('AI returned invalid JSON. Please try again.');
    }
    
    throw new Error(`Failed to generate checklist: ${error.message}`);
  }
}

/**
 * Rate limiting check
 */
const rateLimitMap = new Map();

function checkRateLimit(userId) {
  const key = `ai-gen-${userId}`;
  const now = Date.now();
  const userRequests = rateLimitMap.get(key) || [];
  
  // Remove requests older than 1 hour
  const recentRequests = userRequests.filter(time => now - time < 3600000);
  
  if (recentRequests.length >= 10) {
    const oldestRequest = Math.min(...recentRequests);
    const minutesUntilReset = Math.ceil((3600000 - (now - oldestRequest)) / 60000);
    return { allowed: false, minutesUntilReset };
  }
  
  recentRequests.push(now);
  rateLimitMap.set(key, recentRequests);
  return { allowed: true, remaining: 10 - recentRequests.length };
}

module.exports = {
  generateChecklistFromIssue,
  generateChecklistFromActionItem,
  checkRateLimit
};
4. API Endpoints (add to server.js)
javascriptconst { generateChecklistFromIssue, generateChecklistFromActionItem, checkRateLimit } = require('./server/ai-service');

// ========================================
// AI CHECKLIST GENERATION ENDPOINTS
// ========================================

// POST /api/checklists/generate-from-issue
app.post('/api/checklists/generate-from-issue', authenticateToken, async (req, res) => {
  try {
    const { issue_id, custom_instructions } = req.body;
    const userId = req.user.id;
    
    // Rate limiting
    const rateLimit = checkRateLimit(userId);
    if (!rateLimit.allowed) {
      return res.status(429).json({ 
        error: 'Rate limit exceeded',
        message: `Maximum 10 generations per hour. Try again in ${rateLimit.minutesUntilReset} minutes.`
      });
    }
    
    // Get issue details
    const issueResult = await pool.query(
      `SELECT 
        i.*,
        p.id as project_id,
        p.name as project_name,
        u.name as creator_name
      FROM issues i
      INNER JOIN projects p ON i.project_id = p.id
      LEFT JOIN users u ON i.created_by = u.id
      WHERE i.id = $1`,
      [issue_id]
    );
    
    if (issueResult.rows.length === 0) {
      return res.status(404).json({ error: 'Issue not found' });
    }
    
    const issue = issueResult.rows[0];
    
    // Check user has access to this project
    const accessCheck = await pool.query(
      'SELECT 1 FROM project_members WHERE project_id = $1 AND user_id = $2',
      [issue.project_id, userId]
    );
    
    if (accessCheck.rows.length === 0) {
      return res.status(403).json({ error: 'Access denied to this project' });
    }
    
    // Add custom instructions if provided
    if (custom_instructions) {
      issue.custom_instructions = custom_instructions;
    }
    
    // Generate checklist using AI
    console.log(`Generating checklist from issue ${issue_id}...`);
    const checklistPreview = await generateChecklistFromIssue(issue);
    
    // Add metadata
    checklistPreview.issue_id = issue_id;
    checklistPreview.project_id = issue.project_id;
    checklistPreview.project_name = issue.project_name;
    checklistPreview.source_type = 'issue';
    checklistPreview.source_title = issue.title;
    checklistPreview.generated_at = new Date().toISOString();
    checklistPreview.rate_limit_remaining = rateLimit.remaining;
    
    res.json(checklistPreview);
    
  } catch (error) {
    console.error('Error generating checklist from issue:', error);
    res.status(500).json({ 
      error: 'Failed to generate checklist',
      message: error.message 
    });
  }
});

// POST /api/checklists/generate-from-action
app.post('/api/checklists/generate-from-action', authenticateToken, async (req, res) => {
  try {
    const { action_id, custom_instructions } = req.body;
    const userId = req.user.id;
    
    // Rate limiting
    const rateLimit = checkRateLimit(userId);
    if (!rateLimit.allowed) {
      return res.status(429).json({ 
        error: 'Rate limit exceeded',
        message: `Maximum 10 generations per hour. Try again in ${rateLimit.minutesUntilReset} minutes.`
      });
    }
    
    // Get action item details
    const actionResult = await pool.query(
      `SELECT 
        ai.*,
        p.id as project_id,
        p.name as project_name,
        u.name as assigned_to_name
      FROM action_items ai
      INNER JOIN projects p ON ai.project_id = p.id
      LEFT JOIN users u ON ai.assigned_to = u.id
      WHERE ai.id = $1`,
      [action_id]
    );
    
    if (actionResult.rows.length === 0) {
      return res.status(404).json({ error: 'Action item not found' });
    }
    
    const actionItem = actionResult.rows[0];
    
    // Check user has access to this project
    const accessCheck = await pool.query(
      'SELECT 1 FROM project_members WHERE project_id = $1 AND user_id = $2',
      [actionItem.project_id, userId]
    );
    
    if (accessCheck.rows.length === 0) {
      return res.status(403).json({ error: 'Access denied to this project' });
    }
    
    // Add custom instructions if provided
    if (custom_instructions) {
      actionItem.custom_instructions = custom_instructions;
    }
    
    // Generate checklist using AI
    console.log(`Generating checklist from action item ${action_id}...`);
    const checklistPreview = await generateChecklistFromActionItem(actionItem);
    
    // Add metadata
    checklistPreview.action_id = action_id;
    checklistPreview.project_id = actionItem.project_id;
    checklistPreview.project_name = actionItem.project_name;
    checklistPreview.source_type = 'action-item';
    checklistPreview.source_title = actionItem.title;
    checklistPreview.generated_at = new Date().toISOString();
    checklistPreview.rate_limit_remaining = rateLimit.remaining;
    
    res.json(checklistPreview);
    
  } catch (error) {
    console.error('Error generating checklist from action:', error);
    res.status(500).json({ 
      error: 'Failed to generate checklist',
      message: error.message 
    });
  }
});

// POST /api/checklists/confirm-generated - Create checklist from preview
app.post('/api/checklists/confirm-generated', authenticateToken, async (req, res) => {
  try {
    const { preview, source_id, source_type, project_id } = req.body;
    const userId = req.user.id;
    
    // Verify access
    const accessCheck = await pool.query(
      'SELECT 1 FROM project_members WHERE project_id = $1 AND user_id = $2',
      [project_id, userId]
    );
    
    if (accessCheck.rows.length === 0) {
      return res.status(403).json({ error: 'Access denied' });
    }
    
    const client = await pool.connect();
    
    try {
      await client.query('BEGIN');
      
      let templateId = preview.template_id;
      let totalItems = 0;
      
      // HYBRID APPROACH: Create template (marked as non-reusable if AI-generated)
      if (!preview.use_template || !templateId) {
        // Create AI-generated template (non-reusable by default)
        const templateResult = await client.query(
          `INSERT INTO checklist_templates (
            name, description, category, icon, is_system, is_reusable, created_by
          ) VALUES ($1, $2, $3, $4, $5, $6, $7)
          RETURNING id`,
          [
            preview.title,
            preview.description || 'AI-generated checklist template',
            'ai-generated',
            'sparkles',
            false,
            false,  // NOT REUSABLE - hidden from main template list
            userId
          ]
        );
        
        templateId = templateResult.rows[0].id;
        
        // Create sections and items
        for (let i = 0; i < preview.sections.length; i++) {
          const section = preview.sections[i];
          
          const sectionResult = await client.query(
            `INSERT INTO checklist_template_sections (
              template_id, title, description, section_number, display_order
            ) VALUES ($1, $2, $3, $4, $5)
            RETURNING id`,
            [templateId, section.title, section.description || '', `${i + 1}`, i]
          );
          
          const sectionId = sectionResult.rows[0].id;
          
          // Create items
          for (let j = 0; j < section.items.length; j++) {
            const item = section.items[j];
            
            await client.query(
              `INSERT INTO checklist_template_items (
                section_id, item_text, field_type, field_options, 
                is_required, help_text, display_order
              ) VALUES ($1, $2, $3, $4, $5, $6, $7)`,
              [
                sectionId,
                item.text,
                item.field_type,
                item.field_options ? JSON.stringify(item.field_options) : null,
                item.is_required || false,
                item.help_text || null,
                j
              ]
            );
            
            totalItems++;
          }
        }
      } else {
        // Using existing template - get item count
        const countResult = await client.query(
          `SELECT COUNT(*) as count
           FROM checklist_template_items cti
           INNER JOIN checklist_template_sections cts ON cti.section_id = cts.id
           WHERE cts.template_id = $1`,
          [templateId]
        );
        totalItems = parseInt(countResult.rows[0].count);
      }
      
      // Create checklist
      const checklistId = generateChecklistId();
      
      // Determine which foreign key to set
      const relatedIssueId = source_type === 'issue' ? source_id : null;
      const relatedActionId = source_type === 'action-item' ? source_id : null;
      
      const checklistResult = await client.query(
        `INSERT INTO checklists (
          checklist_id, template_id, project_id, title, description,
          related_issue_id, related_action_id, 
          is_ai_generated, generation_source,
          total_items, created_by
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
        RETURNING *`,
        [
          checklistId,
          templateId,
          project_id,
          preview.title,
          preview.description || `AI-generated from ${source_type}`,
          relatedIssueId,
          relatedActionId,
          true,  // is_ai_generated
          source_type,  // 'issue' or 'action-item'
          totalItems,
          userId
        ]
      );
      
      // Create notification for source creator if different
      let sourceCreatorId = null;
      if (source_type === 'issue') {
        const issueResult = await client.query(
          'SELECT created_by FROM issues WHERE id = $1',
          [source_id]
        );
        sourceCreatorId = issueResult.rows[0]?.created_by;
      } else if (source_type === 'action-item') {
        const actionResult = await client.query(
          'SELECT assigned_to FROM action_items WHERE id = $1',
          [source_id]
        );
        sourceCreatorId = actionResult.rows[0]?.assigned_to;
      }
      
      if (sourceCreatorId && sourceCreatorId !== userId) {
        await client.query(
          `INSERT INTO notifications (user_id, type, title, message, link)
           VALUES ($1, $2, $3, $4, $5)`,
          [
            sourceCreatorId,
            'checklist-generated',
            'ü§ñ AI Generated Checklist',
            `A checklist was generated for your ${source_type}: ${preview.title}`,
            `/checklist-fill.html?id=${checklistResult.rows[0].id}`
          ]
        );
      }
      
      await client.query('COMMIT');
      
      res.status(201).json({
        success: true,
        checklist: checklistResult.rows[0],
        template_id: templateId,
        is_new_template: !preview.use_template,
        message: 'Checklist created successfully'
      });
      
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
    
  } catch (error) {
    console.error('Error confirming checklist:', error);
    res.status(500).json({ 
      error: 'Failed to create checklist',
      message: error.message 
    });
  }
});

// GET /api/templates - Update to filter non-reusable templates
app.get('/api/templates', authenticateToken, async (req, res) => {
  try {
    const { include_ai_generated } = req.query;
    
    let query = `
      SELECT 
        ct.*,
        u.name as created_by_name,
        COUNT(DISTINCT c.id) as usage_count
      FROM checklist_templates ct
      LEFT JOIN users u ON ct.created_by = u.id
      LEFT JOIN checklists c ON ct.id = c.template_id
      WHERE ct.is_active = true
    `;
    
    // By default, hide AI-generated non-reusable templates
    if (include_ai_generated !== 'true') {
      query += ` AND ct.is_reusable = true`;
    }
    
    query += `
      GROUP BY ct.id, u.name
      ORDER BY ct.is_system DESC, ct.name ASC
    `;
    
    const result = await pool.query(query);
    res.json(result.rows);
    
  } catch (error) {
    console.error('Error fetching templates:', error);
    res.status(500).json({ error: 'Failed to fetch templates' });
  }
});

// POST /api/templates/:id/promote - Promote AI template to reusable
app.post('/api/templates/:id/promote', authenticateToken, async (req, res) => {
  try {
    const templateId = req.params.id;
    const userId = req.user.id;
    
    // Verify user created this template or is admin
    const template = await pool.query(
      'SELECT * FROM checklist_templates WHERE id = $1',
      [templateId]
    );
    
    if (template.rows.length === 0) {
      return res.status(404).json({ error: 'Template not found' });
    }
    
    if (template.rows[0].created_by !== userId) {
      return res.status(403).json({ error: 'You can only promote your own templates' });
    }
    
    // Promote to reusable
    await pool.query(
      `UPDATE checklist_templates 
       SET is_reusable = true, 
           category = 'custom',
           icon = 'file-check'
       WHERE id = $1`,
      [templateId]
    );
    
    res.json({ 
      success: true, 
      message: 'Template promoted to reusable. It will now appear in the template list.' 
    });
    
  } catch (error) {
    console.error('Error promoting template:', error);
    res.status(500).json({ error: 'Failed to promote template' });
  }
});
5. Frontend Implementation
Create public/js/ai-checklist.js:
javascript// AI Checklist Generation Functions

let currentPreview = null;

/**
 * Generate checklist from issue
 */
async function generateChecklistFromIssue() {
  const issueId = getIssueIdFromURL();
  
  if (!issueId) {
    showToast('No issue selected', 'error');
    return;
  }
  
  await generateChecklist('issue', issueId);
}

/**
 * Generate checklist from action item
 */
async function generateChecklistFromAction() {
  const actionId = getActionIdFromURL();
  
  if (!actionId) {
    showToast('No action item selected', 'error');
    return;
  }
  
  await generateChecklist('action-item', actionId);
}

/**
 * Generic generate function for both sources
 */
async function generateChecklist(sourceType, sourceId) {
  showAIGenerationModal(sourceType);
  
  const endpoint = sourceType === 'issue' 
    ? '/api/checklists/generate-from-issue'
    : '/api/checklists/generate-from-action';
  
  const bodyKey = sourceType === 'issue' ? 'issue_id' : 'action_id';
  
  try {
    const response = await fetch(endpoint, {
      method: 'POST',
      credentials: 'include',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ [bodyKey]: sourceId })
    });
    
    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.message || error.error || 'Generation failed');
    }
    
    currentPreview = await response.json();
    displayChecklistPreview(currentPreview);
    
  } catch (error) {
    console.error('Generation error:', error);
    hideAIGenerationModal();
    showToast(`Failed to generate checklist: ${error.message}`, 'error');
  }
}

/**
 * Show AI generation modal with loading state
 */
function showAIGenerationModal(sourceType) {
  let modal = document.getElementById('aiGenerationModal');
  
  if (!modal) {
    const modalHTML = `
      <div id="aiGenerationModal" class="modal">
        <div class="modal-content modal-large">
          <div class="modal-header">
            <h3>ü§ñ AI Checklist Generation</h3>
            <button onclick="hideAIGenerationModal()" class="close-btn">&times;</button>
          </div>
          <div id="aiModalBody" class="modal-body">
            <!-- Content will be inserted here -->
          </div>
        </div>
      </div>
    `;
    document.body.insertAdjacentHTML('beforeend', modalHTML);
    modal = document.getElementById('aiGenerationModal');
  }
  
  const sourceLabel = sourceType === 'issue' ? 'issue' : 'action item';
  
  document.getElementById('aiModalBody').innerHTML = `
    <div class="ai-loading">
      <div class="spinner"></div>
      <p>üß† Analyzing ${sourceLabel} and generating checklist...</p>
      <p class="text-muted">This typically takes 10-30 seconds</p>
      <div class="loading-tips">
        <p><strong>What's happening:</strong></p>
        <ul>
          <li>üìñ Reading ${sourceLabel} details</li>
          <li>ü§î Analyzing requirements</li>
          <li>üìã Creating checklist structure</li>
          <li>‚ú® Generating specific items</li>
        </ul>
      </div>
    </div>
  `;
  
  modal.style.display = 'block';
}

/**
 * Hide AI generation modal
 */
function hideAIGenerationModal() {
  const modal = document.getElementById('aiGenerationModal');
  if (modal) {
    modal.style.display = 'none';
  }
  currentPreview = null;
}

/**
 * Display checklist preview for user review
 */
function displayChecklistPreview(preview) {
  const totalItems = preview.sections.reduce((sum, section) => 
    sum + section.items.length, 0
  );
  
  const sourceLabel = preview.source_type === 'issue' ? 'Issue' : 'Action Item';
  const sourceIcon = preview.source_type === 'issue' ? 'üêõ' : '‚úÖ';
  
  const html = `
    <div class="preview-container">
      <div class="preview-header">
        <div class="preview-meta">
          <span class="badge badge-success">‚ú® AI Generated</span>
          <span class="badge badge-info">Confidence: ${preview.confidence}%</span>
          <span class="badge badge-secondary">${totalItems} items</span>
          <span class="badge badge-purple">${sourceIcon} From ${sourceLabel}</span>
        </div>
        <h4>${preview.title}</h4>
        <p>${preview.description}</p>
        
        <div class="preview-source">
          <strong>Source:</strong> ${preview.source_title}
        </div>
        
        ${preview.use_template ? 
          '<div class="alert alert-info">üìã Using existing template: <strong>Access Verification Checklist</strong></div>' : 
          '<div class="alert alert-warning">‚ú® Custom checklist generated specifically for this ' + sourceLabel.toLowerCase() + '</div>'
        }
        
        ${preview.rate_limit_remaining !== undefined ?
          `<div class="rate-limit-info">
            <small>üí° ${preview.rate_limit_remaining} AI generations remaining this hour</small>
          </div>` : ''
        }
      </div>
      
      <div class="preview-reasoning">
        <strong>ü§î AI Reasoning:</strong>
        <p>${preview.reasoning}</p>
      </div>
      
      <div class="preview-sections">
        <h5>üìã Checklist Structure Preview:</h5>
        ${preview.sections.map((section, idx) => `
          <div class="preview-section">
            <div class="section-header">
              <h6>${idx + 1}. ${section.title}</h6>
              <span class="item-count">${section.items.length} items</span>
            </div>
            ${section.description ? 
              `<p class="section-description">${section.description}</p>` : 
              ''
            }
            <ul class="preview-items">
              ${section.items.slice(0, 5).map(item => `
                <li>
                  <span class="field-type-badge field-type-${item.field_type}">${item.field_type}</span>
                  <span class="item-text">${item.text}</span>
                  ${item.is_required ? '<span class="required" title="Required">*</span>' : ''}
                  ${item.help_text ? `<div class="help-text">${item.help_text}</div>` : ''}
                </li>
              `).join('')}
              ${section.items.length > 5 ? 
                `<li class="more-items">
                  <span class="text-muted">... and ${section.items.length - 5} more items</span>
                </li>` : 
                ''
              }
            </ul>
          </div>
        `).join('')}
      </div>
      
      <div class="preview-actions">
        <button onclick="confirmGeneratedChecklist()" class="btn-primary btn-large">
          ‚úÖ Create This Checklist
        </button>
        <button onclick="regenerateWithInstructions()" class="btn-secondary">
          üîÑ Regenerate with Instructions
        </button>
        <button onclick="hideAIGenerationModal()" class="btn-secondary">
          ‚ùå Cancel
        </button>
      </div>
    </div>
  `;
  
  document.getElementById('aiModalBody').innerHTML = html;
}

/**
 * Confirm and create checklist from preview
 */
async function confirmGeneratedChecklist() {
  if (!currentPreview) {
    showToast('No preview available', 'error');
    return;
  }
  
  // Show saving state
  document.querySelector('.preview-actions').innerHTML = `
    <div class="saving-state">
      <div class="spinner-small"></div>
      <p>Creating checklist...</p>
    </div>
  `;
  
  try {
    const sourceId = currentPreview.issue_id || currentPreview.action_id;
    const sourceType = currentPreview.source_type;
    
    const response = await fetch('/api/checklists/confirm-generated', {
      method: 'POST',
      credentials: 'include',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        preview: currentPreview,
        source_id: sourceId,
        source_type: sourceType,
        project_id: currentPreview.project_id
      })
    });
    
    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.message || 'Failed to create checklist');
    }
    
    const result = await response.json();
    
    // Success!
    hideAIGenerationModal();
    showToast('‚ú® Checklist created successfully!', 'success');
    
    // Show promotion option if new template was created
    if (result.is_new_template) {
      setTimeout(() => {
        if (confirm('Would you like to save this as a reusable template for future use?')) {
          promoteTemplate(result.template_id);
        }
      }, 2000);
    }
    
    // Redirect to checklist
    setTimeout(() => {
      window.location.href = `/checklist-fill.html?id=${result.checklist.id}`;
    }, 1500);
    
  } catch (error) {
    console.error('Confirmation error:', error);
    showToast(`Failed to create checklist: ${error.message}`, 'error');
    
    // Restore buttons
    displayChecklistPreview(currentPreview);
  }
}

/**
 * Regenerate with custom instructions
 */
function regenerateWithInstructions() {
  // TODO: Show input for custom instructions, then regenerate
  showToast('Custom instructions feature coming soon!', 'info');
}

/**
 * Promote AI template to reusable
 */
async function promoteTemplate(templateId) {
  try {
    const response = await fetch(`/api/templates/${templateId}/promote`, {
      method: 'POST',
      credentials: 'include'
    });
    
    if (!response.ok) {
      throw new Error('Failed to promote template');
    }
    
    showToast('‚ú® Template saved for future use!', 'success');
    
  } catch (error) {
    console.error('Promotion error:', error);
    showToast('Could not save template', 'error');
  }
}

/**
 * Helper: Get issue ID from URL
 */
function getIssueIdFromURL() {
  const params = new URLSearchParams(window.location.search);
  return params.get('id') || params.get('issue_id');
}

/**
 * Helper: Get action ID from URL
 */
function getActionIdFromURL() {
  const params = new URLSearchParams(window.location.search);
  return params.get('id') || params.get('action_id');
}

/**
 * Helper: Show toast notification
 */
function showToast(message, type = 'info') {
  // Remove existing toasts
  document.querySelectorAll('.toast').forEach(t => t.remove());
  
  const toast = document.createElement('div');
  toast.className = `toast toast-${type}`;
  toast.innerHTML = `
    <div class="toast-content">
      ${type === 'success' ? '‚úÖ' : type === 'error' ? '‚ùå' : '‚ÑπÔ∏è'}
      <span>${message}</span>
    </div>
  `;
  document.body.appendChild(toast);
  
  setTimeout(() => {
    toast.classList.add('show');
  }, 100);
  
  setTimeout(() => {
    toast.classList.remove('show');
    setTimeout(() => toast.remove(), 300);
  }, 4000);
}
Update issues.html (or issue detail page):
html<!-- Add button to issue detail view -->
<div class="issue-actions">
  <!-- Existing buttons -->
  <button onclick="generateChecklistFromIssue()" class="btn-ai">
    ü§ñ Generate Checklist
  </button>
</div>

<!-- Add script -->
<script src="js/ai-checklist.js"></script>
Update action-items.html (or action detail page):
html<!-- Add button to action item detail view -->
<div class="action-actions">
  <!-- Existing buttons -->
  <button onclick="generateChecklistFromAction()" class="btn-ai">
    ü§ñ Generate Checklist
  </button>
</div>

<!-- Add script -->
<script src="js/ai-checklist.js"></script>
6. CSS Styling
Add to public/css/checklists.css:
css/* AI Generation Styles */
.btn-ai {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  border: none;
  padding: 10px 20px;
  border-radius: 8px;
  cursor: pointer;
  font-weight: 600;
  font-size: 14px;
  transition: all 0.3s;
  box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
}

.btn-ai:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 16px rgba(102, 126, 234, 0.5);
}

.modal-large {
  max-width: 900px;
  max-height: 90vh;
  overflow-y: auto;
}

.ai-loading {
  text-align: center;
  padding: 60px 40px;
}

.spinner {
  border: 4px solid #f3f3f3;
  border-top: 4px solid #667eea;
  border-radius: 50%;
  width: 60px;
  height: 60px;
  animation: spin 1s linear infinite;
  margin: 0 auto 25px;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

.loading-tips {
  margin-top: 30px;
  text-align: left;
  max-width: 400px;
  margin-left: auto;
  margin-right: auto;
  padding: 20px;
  background: #f8f9fa;
  border-radius: 8px;
}

.loading-tips ul {
  list-style: none;
  padding: 0;
  margin: 10px 0 0 0;
}

.loading-tips li {
  padding: 8px 0;
  color: #6b7280;
}

.preview-container {
  padding: 0;
}

.preview-header {
  padding: 25px;
  background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
  border-radius: 12px;
  margin-bottom: 25px;
}

.preview-meta {
  display: flex;
  gap: 10px;
  margin-bottom: 20px;
  flex-wrap: wrap;
}

.badge {
  padding: 6px 14px;
  border-radius: 16px;
  font-size: 12px;
  font-weight: 600;
  letter-spacing: 0.5px;
}

.badge-success { background: #10b981; color: white; }
.badge-info { background: #3b82f6; color: white; }
.badge-secondary { background: #6b7280; color: white; }
.badge-warning { background: #f59e0b; color: white; }
.badge-purple { background: #8b5cf6; color: white; }

.preview-source {
  margin-top: 15px;
  padding: 12px;
  background: white;
  border-radius: 6px;
  font-size: 14px;
}

.alert {
  padding: 12px 16px;
  border-radius: 8px;
  margin-top: 15px;
  font-size: 14px;
}

.alert-info {
  background: #dbeafe;
  border-left: 4px solid #3b82f6;
  color: #1e40af;
}

.alert-warning {
  background: #fef3c7;
  border-left: 4px solid #f59e0b;
  color: #92400e;
}

.rate-limit-info {
  margin-top: 10px;
  color: #6b7280;
}

.preview-reasoning {
  padding: 20px;
  background: #fffbeb;
  border-left: 4px solid #f59e0b;
  margin-bottom: 25px;
  border-radius: 8px;
}

.preview-sections {
  margin: 25px 0;
}

.preview-sections h5 {
  margin-bottom: 20px;
  color: #1f2937;
  font-size: 18px;
}

.preview-section {
  padding: 20px;
  background: white;
  border: 2px solid #e5e7eb;
  border-radius: 10px;
  margin-bottom: 20px;
  transition: all 0.2s;
}

.preview-section:hover {
  border-color: #667eea;
  box-shadow: 0 2px 8px rgba(102, 126, 234, 0.1);
}

.section-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
}

.section-header h6 {
  color: #1f2937;
  margin: 0;
  font-size: 16px;
}

.item-count {
  background: #e5e7eb;
  padding: 4px 12px;
  border-radius: 12px;
  font-size: 12px;
  font-weight: 600;
  color: #6b7280;
}

.section-description {
  color: #6b7280;
  font-size: 14px;
  margin: 8px 0 15px 0;
  font-style: italic;
}

.preview-items {
  list-style: none;
  padding: 0;
  margin: 0;
}

.preview-items li {
  padding: 12px 0;
  border-bottom: 1px solid #f3f4f6;
  display: flex;
  align-items: flex-start;
  gap: 12px;
}

.preview-items li:last-child {
  border-bottom: none;
}

.field-type-badge {
  display: inline-block;
  padding: 4px 10px;
  border-radius: 6px;
  font-size: 10px;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  flex-shrink: 0;
}

.field-type-checkbox { background: #dbeafe; color: #1e40af; }
.field-type-text { background: #d1fae5; color: #065f46; }
.field-type-textarea { background: #fef3c7; color: #92400e; }
.field-type-date { background: #fce7f3; color: #9f1239; }
.field-type-radio { background: #e9d5ff; color: #6b21a8; }

.item-text {
  flex: 1;
  color: #374151;
  line-height: 1.5;
}

.help-text {
  margin-top: 6px;
  padding: 8px 12px;
  background: #f9fafb;
  border-radius: 6px;
  font-size: 12px;
  color: #6b7280;
  font-style: italic;
}

.required {
  color: #ef4444;
  font-weight: bold;
  font-size: 16px;
  flex-shrink: 0;
}

.more-items {
  padding: 8px 0 !important;
  justify-content: center;
}

.preview-actions {
  display: flex;
  gap: 15px;
  justify-content: center;
  padding: 25px;
  border-top: 2px solid #e5e7eb;
  margin-top: 25px;
  background: #f9fafb;
  border-radius: 0 0 12px 12px;
}

.btn-large {
  padding: 14px 32px;
  font-size: 16px;
}

.saving-state {
  text-align: center;
  padding: 20px;
}

.spinner-small {
  border: 3px solid #f3f3f3;
  border-top: 3px solid #667eea;
  border-radius: 50%;
  width: 40px;
  height: 40px;
  animation: spin 1s linear infinite;
  margin: 0 auto 15px;
}

.toast {
  position: fixed;
  bottom: 30px;
  right: 30px;
  padding: 16px 24px;
  background: white;
  border-radius: 10px;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
  opacity: 0;
  transform: translateY(20px);
  transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
  z-index: 10000;
  min-width: 300px;
}

.toast.show {
  opacity: 1;
  transform: translateY(0);
}

.toast-content {
  display: flex;
  align-items: center;
  gap: 12px;
  font-size: 15px;
}

.toast-success {
  border-left: 4px solid #10b981;
}

.toast-error {
  border-left: 4px solid #ef4444;
}

.toast-info {
  border-left: 4px solid #3b82f6;
}

/* Responsive */
@media (max-width: 768px) {
  .modal-large {
    max-width: 95%;
    margin: 20px auto;
  }
  
  .preview-actions {
    flex-direction: column;
  }
  
  .preview-meta {
    justify-content: center;
  }
  
  .toast {
    right: 15px;
    left: 15px;
    bottom: 15px;
    min-width: auto;
  }
}

TESTING
After implementation, test with these scenarios:
Test 1: Generate from Issue

Navigate to any issue detail page
Click "ü§ñ Generate Checklist" button
Wait for AI generation
Review preview
Click "Create This Checklist"
Verify checklist created and linked to issue

Test 2: Generate from Action Item

Navigate to any action item detail page
Click "ü§ñ Generate Checklist" button
Wait for AI generation
Review preview
Click "Create This Checklist"
Verify checklist created and linked to action

Test 3: Template Promotion

After creating AI-generated checklist
When prompted, choose to save as reusable template
Go to template list
Verify template now appears

Test 4: Rate Limiting

Generate 10 checklists in quick succession
On 11th attempt, should see rate limit error
Wait 1 hour or check error message

Test 5: Template Filtering

Go to template list (GET /api/templates)
By default, should NOT see AI-generated non-reusable templates
Add ?include_ai_generated=true to URL
Now should see all templates including AI ones


CRITICAL REQUIREMENTS

‚úÖ Database migrations run successfully
‚úÖ AI API key configured in .env
‚úÖ Both issue and action endpoints working
‚úÖ Hybrid template approach implemented
‚úÖ Rate limiting prevents abuse
‚úÖ Template promotion feature working
‚úÖ Template filtering hides non-reusable by default
‚úÖ Error handling for AI failures
‚úÖ Loading states shown during generation
‚úÖ Checklists link to source (issue or action)


DELIVERABLES

‚úÖ SQL migrations executed
‚úÖ server/ai-service.js created
‚úÖ API endpoints in server.js (4 new endpoints)
‚úÖ public/js/ai-checklist.js created
‚úÖ Generate buttons on issue and action pages
‚úÖ AI generation modal functional
‚úÖ Preview and confirmation flow working
‚úÖ CSS styling applied
‚úÖ Template promotion feature working
‚úÖ Rate limiting implemented


OUTPUT REQUIRED
Confirm when complete:

"Database migrations successful" ‚úÖ
"AI service integrated with OpenAI/Anthropic" ‚úÖ
"Both issue and action endpoints working" ‚úÖ
"Hybrid template approach implemented" ‚úÖ
"Successfully generated checklists from both sources" ‚úÖ
"Template promotion tested" ‚úÖ
CONTEXT:
Phase 2a of Checklist System - Core AI features. Phase 1 complete with:
- 7 database tables (templates, sections, items, checklists, responses, comments, signoffs)
- 6 CRUD API endpoints functional
- Access Verification template seeded (303 items)
- Full UI for creating and filling checklists

TASK:
Implement AI-powered checklist generation from BOTH issues and action items using a hybrid template approach. AI-generated templates are marked as non-reusable by default (hidden from main template list) but can be promoted to reusable templates if users find them valuable.

ESTIMATED TIME: 6-8 hours

---

## REQUIREMENTS

### 1. Database Schema Updates

**Run these SQL migrations:**
```sql
-- Add flags to support hybrid template approach
ALTER TABLE checklist_templates 
ADD COLUMN is_reusable BOOLEAN DEFAULT true;

ALTER TABLE checklists 
ADD COLUMN is_ai_generated BOOLEAN DEFAULT false,
ADD COLUMN generation_source VARCHAR(50); -- 'issue' or 'action-item'

-- Update existing templates to be reusable
UPDATE checklist_templates SET is_reusable = true WHERE is_reusable IS NULL;

-- Add index for filtering non-reusable templates
CREATE INDEX idx_templates_reusable ON checklist_templates(is_reusable);

-- Add comment to explain the columns
COMMENT ON COLUMN checklist_templates.is_reusable IS 'True for user-created/system templates. False for AI-generated one-off templates that are hidden by default.';
COMMENT ON COLUMN checklists.is_ai_generated IS 'True if this checklist was generated by AI';
COMMENT ON COLUMN checklists.generation_source IS 'Source of AI generation: issue, action-item, or document';
2. Environment Variables
Add to .env file:
env# Choose ONE AI provider
OPENAI_API_KEY=your_openai_key_here
# OR
ANTHROPIC_API_KEY=your_claude_key_here

# AI Configuration
AI_PROVIDER=openai  # or 'anthropic'
AI_MODEL=gpt-4o
AI_MAX_TOKENS=2000
AI_TIMEOUT=30000
Install Dependencies:
bashnpm install openai @anthropic-ai/sdk
3. Backend Implementation
Create new file: server/ai-service.js
javascriptconst OpenAI = require('openai');
const Anthropic = require('@anthropic-ai/sdk');

const AI_PROVIDER = process.env.AI_PROVIDER || 'openai';

// Initialize AI client
let aiClient;
if (AI_PROVIDER === 'openai') {
  aiClient = new OpenAI({
    apiKey: process.env.OPENAI_API_KEY
  });
} else if (AI_PROVIDER === 'anthropic') {
  aiClient = new Anthropic({
    apiKey: process.env.ANTHROPIC_API_KEY
  });
}

/**
 * Generate checklist from issue
 */
async function generateChecklistFromIssue(issue) {
  const prompt = `You are a project management expert. Analyze this issue and generate a detailed checklist to address it.

Issue Title: ${issue.title}
Issue Description: ${issue.description || 'No description provided'}
Issue Type: ${issue.type || 'Unknown'}
Priority: ${issue.priority || 'Medium'}
Status: ${issue.status || 'Open'}
Labels: ${issue.labels || 'None'}

Based on this issue, generate a comprehensive checklist with:
1. A descriptive checklist title that clearly indicates the purpose
2. 3-7 main sections (logical groupings of related tasks)
3. 5-15 checklist items per section
4. Appropriate field types for each item
5. Mark critical items as required

For field types, use:
- "checkbox" for yes/no confirmations and completion checks
- "text" for short answers (names, IDs, hostnames, single values)
- "textarea" for detailed notes, descriptions, or long-form content
- "date" for dates, deadlines, and timestamps
- "radio" for multiple choice selections (include 2-5 options in field_options array)

IMPORTANT TEMPLATE MATCHING:
- If this issue is about verifying server access, checking credentials, or validating permissions/connectivity, set use_template=true and template_id=1 (Access Verification Checklist)
- Otherwise, generate a custom checklist structure with use_template=false and template_id=null

Respond ONLY with valid JSON in this exact format (no markdown, no code blocks):
{
  "title": "Clear, action-oriented checklist title",
  "description": "Brief description of checklist purpose and scope",
  "use_template": true or false,
  "template_id": 1 or null,
  "confidence": 75,
  "sections": [
    {
      "title": "Section name (e.g., 'Initial Setup', 'Validation Steps')",
      "description": "Brief description of this section's purpose",
      "items": [
        {
          "text": "Clear, actionable item description",
          "field_type": "checkbox|text|textarea|date|radio",
          "field_options": ["Option 1", "Option 2", "Option 3"] or null,
          "is_required": true or false,
          "help_text": "Optional guidance for completing this item"
        }
      ]
    }
  ],
  "reasoning": "1-2 sentence explanation of why this checklist structure was chosen"
}

Requirements:
- Minimum 20 total items across all sections
- At least 3 sections
- Mix of field types (not all checkboxes)
- Specific and actionable items
- Professional language`;

  return await callAI(prompt, 'issue');
}

/**
 * Generate checklist from action item
 */
async function generateChecklistFromActionItem(actionItem) {
  const prompt = `You are a project management expert. Analyze this action item and generate a detailed checklist to complete it.

Action Title: ${actionItem.title}
Description: ${actionItem.description || 'No description provided'}
Priority: ${actionItem.priority || 'Medium'}
Status: ${actionItem.status || 'Open'}
Due Date: ${actionItem.due_date || 'Not set'}
Assigned To: ${actionItem.assigned_to_name || 'Unassigned'}

Based on this action item, generate a comprehensive checklist that breaks down this action into concrete, executable steps:

1. A descriptive checklist title
2. 2-5 main sections representing major phases or categories of work
3. 3-10 specific, actionable items per section
4. Appropriate field types for each item
5. Mark critical items as required

For field types, use:
- "checkbox" for completion checks and confirmations
- "text" for capturing specific values, names, or identifiers
- "textarea" for notes, observations, or detailed responses
- "date" for deadlines, completion dates, or timestamps
- "radio" for selecting between predefined options

Think about:
- What are the prerequisite steps?
- What are the main execution steps?
- What validation/verification is needed?
- What documentation or follow-up is required?

Respond ONLY with valid JSON (no markdown formatting):
{
  "title": "Action-oriented checklist title",
  "description": "Brief description of how this checklist helps complete the action",
  "use_template": false,
  "template_id": null,
  "confidence": 80,
  "sections": [
    {
      "title": "Section name",
      "description": "What this section accomplishes",
      "items": [
        {
          "text": "Specific, actionable task description",
          "field_type": "checkbox|text|textarea|date|radio",
          "field_options": ["Option A", "Option B"] or null,
          "is_required": true or false,
          "help_text": "How to complete this step"
        }
      ]
    }
  ],
  "reasoning": "Why this breakdown makes sense for completing the action"
}

Requirements:
- Minimum 10 total items
- At least 2 sections
- Concrete, actionable steps
- Logical sequence`;

  return await callAI(prompt, 'action-item');
}

/**
 * Call AI with prompt and parse response
 */
async function callAI(prompt, sourceType) {
  try {
    let response;
    
    if (AI_PROVIDER === 'openai') {
      const completion = await aiClient.chat.completions.create({
        model: process.env.AI_MODEL || 'gpt-4o',
        messages: [
          { 
            role: 'system', 
            content: 'You are a project management expert who creates detailed, actionable checklists. Always respond with valid JSON only, no markdown formatting, no code blocks.' 
          },
          { role: 'user', content: prompt }
        ],
        temperature: 0.7,
        max_tokens: parseInt(process.env.AI_MAX_TOKENS) || 2000
      });
      
      response = completion.choices[0].message.content;
      
    } else if (AI_PROVIDER === 'anthropic') {
      const message = await aiClient.messages.create({
        model: 'claude-3-5-sonnet-20241022',
        max_tokens: parseInt(process.env.AI_MAX_TOKENS) || 2000,
        messages: [
          { 
            role: 'user', 
            content: `${prompt}\n\nIMPORTANT: Respond with ONLY valid JSON. No markdown code blocks, no explanations before or after.` 
          }
        ]
      });
      
      response = message.content[0].text;
    }
    
    // Clean response - remove markdown code blocks if AI included them
    response = response.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
    
    // Parse JSON
    const checklistData = JSON.parse(response);
    
    // Validate structure
    if (!checklistData.title || !checklistData.sections || !Array.isArray(checklistData.sections)) {
      throw new Error('Invalid checklist structure from AI');
    }
    
    // Validate sections have items
    if (checklistData.sections.length === 0 || !checklistData.sections[0].items) {
      throw new Error('Checklist must have sections with items');
    }
    
    // Add metadata
    checklistData.generation_source = sourceType;
    
    return checklistData;
    
  } catch (error) {
    console.error('AI generation error:', error);
    
    // Check if it's a parsing error
    if (error instanceof SyntaxError) {
      throw new Error('AI returned invalid JSON. Please try again.');
    }
    
    throw new Error(`Failed to generate checklist: ${error.message}`);
  }
}

/**
 * Rate limiting check
 */
const rateLimitMap = new Map();

function checkRateLimit(userId) {
  const key = `ai-gen-${userId}`;
  const now = Date.now();
  const userRequests = rateLimitMap.get(key) || [];
  
  // Remove requests older than 1 hour
  const recentRequests = userRequests.filter(time => now - time < 3600000);
  
  if (recentRequests.length >= 10) {
    const oldestRequest = Math.min(...recentRequests);
    const minutesUntilReset = Math.ceil((3600000 - (now - oldestRequest)) / 60000);
    return { allowed: false, minutesUntilReset };
  }
  
  recentRequests.push(now);
  rateLimitMap.set(key, recentRequests);
  return { allowed: true, remaining: 10 - recentRequests.length };
}

module.exports = {
  generateChecklistFromIssue,
  generateChecklistFromActionItem,
  checkRateLimit
};
4. API Endpoints (add to server.js)
javascriptconst { generateChecklistFromIssue, generateChecklistFromActionItem, checkRateLimit } = require('./server/ai-service');

// ========================================
// AI CHECKLIST GENERATION ENDPOINTS
// ========================================

// POST /api/checklists/generate-from-issue
app.post('/api/checklists/generate-from-issue', authenticateToken, async (req, res) => {
  try {
    const { issue_id, custom_instructions } = req.body;
    const userId = req.user.id;
    
    // Rate limiting
    const rateLimit = checkRateLimit(userId);
    if (!rateLimit.allowed) {
      return res.status(429).json({ 
        error: 'Rate limit exceeded',
        message: `Maximum 10 generations per hour. Try again in ${rateLimit.minutesUntilReset} minutes.`
      });
    }
    
    // Get issue details
    const issueResult = await pool.query(
      `SELECT 
        i.*,
        p.id as project_id,
        p.name as project_name,
        u.name as creator_name
      FROM issues i
      INNER JOIN projects p ON i.project_id = p.id
      LEFT JOIN users u ON i.created_by = u.id
      WHERE i.id = $1`,
      [issue_id]
    );
    
    if (issueResult.rows.length === 0) {
      return res.status(404).json({ error: 'Issue not found' });
    }
    
    const issue = issueResult.rows[0];
    
    // Check user has access to this project
    const accessCheck = await pool.query(
      'SELECT 1 FROM project_members WHERE project_id = $1 AND user_id = $2',
      [issue.project_id, userId]
    );
    
    if (accessCheck.rows.length === 0) {
      return res.status(403).json({ error: 'Access denied to this project' });
    }
    
    // Add custom instructions if provided
    if (custom_instructions) {
      issue.custom_instructions = custom_instructions;
    }
    
    // Generate checklist using AI
    console.log(`Generating checklist from issue ${issue_id}...`);
    const checklistPreview = await generateChecklistFromIssue(issue);
    
    // Add metadata
    checklistPreview.issue_id = issue_id;
    checklistPreview.project_id = issue.project_id;
    checklistPreview.project_name = issue.project_name;
    checklistPreview.source_type = 'issue';
    checklistPreview.source_title = issue.title;
    checklistPreview.generated_at = new Date().toISOString();
    checklistPreview.rate_limit_remaining = rateLimit.remaining;
    
    res.json(checklistPreview);
    
  } catch (error) {
    console.error('Error generating checklist from issue:', error);
    res.status(500).json({ 
      error: 'Failed to generate checklist',
      message: error.message 
    });
  }
});

// POST /api/checklists/generate-from-action
app.post('/api/checklists/generate-from-action', authenticateToken, async (req, res) => {
  try {
    const { action_id, custom_instructions } = req.body;
    const userId = req.user.id;
    
    // Rate limiting
    const rateLimit = checkRateLimit(userId);
    if (!rateLimit.allowed) {
      return res.status(429).json({ 
        error: 'Rate limit exceeded',
        message: `Maximum 10 generations per hour. Try again in ${rateLimit.minutesUntilReset} minutes.`
      });
    }
    
    // Get action item details
    const actionResult = await pool.query(
      `SELECT 
        ai.*,
        p.id as project_id,
        p.name as project_name,
        u.name as assigned_to_name
      FROM action_items ai
      INNER JOIN projects p ON ai.project_id = p.id
      LEFT JOIN users u ON ai.assigned_to = u.id
      WHERE ai.id = $1`,
      [action_id]
    );
    
    if (actionResult.rows.length === 0) {
      return res.status(404).json({ error: 'Action item not found' });
    }
    
    const actionItem = actionResult.rows[0];
    
    // Check user has access to this project
    const accessCheck = await pool.query(
      'SELECT 1 FROM project_members WHERE project_id = $1 AND user_id = $2',
      [actionItem.project_id, userId]
    );
    
    if (accessCheck.rows.length === 0) {
      return res.status(403).json({ error: 'Access denied to this project' });
    }
    
    // Add custom instructions if provided
    if (custom_instructions) {
      actionItem.custom_instructions = custom_instructions;
    }
    
    // Generate checklist using AI
    console.log(`Generating checklist from action item ${action_id}...`);
    const checklistPreview = await generateChecklistFromActionItem(actionItem);
    
    // Add metadata
    checklistPreview.action_id = action_id;
    checklistPreview.project_id = actionItem.project_id;
    checklistPreview.project_name = actionItem.project_name;
    checklistPreview.source_type = 'action-item';
    checklistPreview.source_title = actionItem.title;
    checklistPreview.generated_at = new Date().toISOString();
    checklistPreview.rate_limit_remaining = rateLimit.remaining;
    
    res.json(checklistPreview);
    
  } catch (error) {
    console.error('Error generating checklist from action:', error);
    res.status(500).json({ 
      error: 'Failed to generate checklist',
      message: error.message 
    });
  }
});

// POST /api/checklists/confirm-generated - Create checklist from preview
app.post('/api/checklists/confirm-generated', authenticateToken, async (req, res) => {
  try {
    const { preview, source_id, source_type, project_id } = req.body;
    const userId = req.user.id;
    
    // Verify access
    const accessCheck = await pool.query(
      'SELECT 1 FROM project_members WHERE project_id = $1 AND user_id = $2',
      [project_id, userId]
    );
    
    if (accessCheck.rows.length === 0) {
      return res.status(403).json({ error: 'Access denied' });
    }
    
    const client = await pool.connect();
    
    try {
      await client.query('BEGIN');
      
      let templateId = preview.template_id;
      let totalItems = 0;
      
      // HYBRID APPROACH: Create template (marked as non-reusable if AI-generated)
      if (!preview.use_template || !templateId) {
        // Create AI-generated template (non-reusable by default)
        const templateResult = await client.query(
          `INSERT INTO checklist_templates (
            name, description, category, icon, is_system, is_reusable, created_by
          ) VALUES ($1, $2, $3, $4, $5, $6, $7)
          RETURNING id`,
          [
            preview.title,
            preview.description || 'AI-generated checklist template',
            'ai-generated',
            'sparkles',
            false,
            false,  // NOT REUSABLE - hidden from main template list
            userId
          ]
        );
        
        templateId = templateResult.rows[0].id;
        
        // Create sections and items
        for (let i = 0; i < preview.sections.length; i++) {
          const section = preview.sections[i];
          
          const sectionResult = await client.query(
            `INSERT INTO checklist_template_sections (
              template_id, title, description, section_number, display_order
            ) VALUES ($1, $2, $3, $4, $5)
            RETURNING id`,
            [templateId, section.title, section.description || '', `${i + 1}`, i]
          );
          
          const sectionId = sectionResult.rows[0].id;
          
          // Create items
          for (let j = 0; j < section.items.length; j++) {
            const item = section.items[j];
            
            await client.query(
              `INSERT INTO checklist_template_items (
                section_id, item_text, field_type, field_options, 
                is_required, help_text, display_order
              ) VALUES ($1, $2, $3, $4, $5, $6, $7)`,
              [
                sectionId,
                item.text,
                item.field_type,
                item.field_options ? JSON.stringify(item.field_options) : null,
                item.is_required || false,
                item.help_text || null,
                j
              ]
            );
            
            totalItems++;
          }
        }
      } else {
        // Using existing template - get item count
        const countResult = await client.query(
          `SELECT COUNT(*) as count
           FROM checklist_template_items cti
           INNER JOIN checklist_template_sections cts ON cti.section_id = cts.id
           WHERE cts.template_id = $1`,
          [templateId]
        );
        totalItems = parseInt(countResult.rows[0].count);
      }
      
      // Create checklist
      const checklistId = generateChecklistId();
      
      // Determine which foreign key to set
      const relatedIssueId = source_type === 'issue' ? source_id : null;
      const relatedActionId = source_type === 'action-item' ? source_id : null;
      
      const checklistResult = await client.query(
        `INSERT INTO checklists (
          checklist_id, template_id, project_id, title, description,
          related_issue_id, related_action_id, 
          is_ai_generated, generation_source,
          total_items, created_by
        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
        RETURNING *`,
        [
          checklistId,
          templateId,
          project_id,
          preview.title,
          preview.description || `AI-generated from ${source_type}`,
          relatedIssueId,
          relatedActionId,
          true,  // is_ai_generated
          source_type,  // 'issue' or 'action-item'
          totalItems,
          userId
        ]
      );
      
      // Create notification for source creator if different
      let sourceCreatorId = null;
      if (source_type === 'issue') {
        const issueResult = await client.query(
          'SELECT created_by FROM issues WHERE id = $1',
          [source_id]
        );
        sourceCreatorId = issueResult.rows[0]?.created_by;
      } else if (source_type === 'action-item') {
        const actionResult = await client.query(
          'SELECT assigned_to FROM action_items WHERE id = $1',
          [source_id]
        );
        sourceCreatorId = actionResult.rows[0]?.assigned_to;
      }
      
      if (sourceCreatorId && sourceCreatorId !== userId) {
        await client.query(
          `INSERT INTO notifications (user_id, type, title, message, link)
           VALUES ($1, $2, $3, $4, $5)`,
          [
            sourceCreatorId,
            'checklist-generated',
            '🤖 AI Generated Checklist',
            `A checklist was generated for your ${source_type}: ${preview.title}`,
            `/checklist-fill.html?id=${checklistResult.rows[0].id}`
          ]
        );
      }
      
      await client.query('COMMIT');
      
      res.status(201).json({
        success: true,
        checklist: checklistResult.rows[0],
        template_id: templateId,
        is_new_template: !preview.use_template,
        message: 'Checklist created successfully'
      });
      
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
    
  } catch (error) {
    console.error('Error confirming checklist:', error);
    res.status(500).json({ 
      error: 'Failed to create checklist',
      message: error.message 
    });
  }
});

// GET /api/templates - Update to filter non-reusable templates
app.get('/api/templates', authenticateToken, async (req, res) => {
  try {
    const { include_ai_generated } = req.query;
    
    let query = `
      SELECT 
        ct.*,
        u.name as created_by_name,
        COUNT(DISTINCT c.id) as usage_count
      FROM checklist_templates ct
      LEFT JOIN users u ON ct.created_by = u.id
      LEFT JOIN checklists c ON ct.id = c.template_id
      WHERE ct.is_active = true
    `;
    
    // By default, hide AI-generated non-reusable templates
    if (include_ai_generated !== 'true') {
      query += ` AND ct.is_reusable = true`;
    }
    
    query += `
      GROUP BY ct.id, u.name
      ORDER BY ct.is_system DESC, ct.name ASC
    `;
    
    const result = await pool.query(query);
    res.json(result.rows);
    
  } catch (error) {
    console.error('Error fetching templates:', error);
    res.status(500).json({ error: 'Failed to fetch templates' });
  }
});

// POST /api/templates/:id/promote - Promote AI template to reusable
app.post('/api/templates/:id/promote', authenticateToken, async (req, res) => {
  try {
    const templateId = req.params.id;
    const userId = req.user.id;
    
    // Verify user created this template or is admin
    const template = await pool.query(
      'SELECT * FROM checklist_templates WHERE id = $1',
      [templateId]
    );
    
    if (template.rows.length === 0) {
      return res.status(404).json({ error: 'Template not found' });
    }
    
    if (template.rows[0].created_by !== userId) {
      return res.status(403).json({ error: 'You can only promote your own templates' });
    }
    
    // Promote to reusable
    await pool.query(
      `UPDATE checklist_templates 
       SET is_reusable = true, 
           category = 'custom',
           icon = 'file-check'
       WHERE id = $1`,
      [templateId]
    );
    
    res.json({ 
      success: true, 
      message: 'Template promoted to reusable. It will now appear in the template list.' 
    });
    
  } catch (error) {
    console.error('Error promoting template:', error);
    res.status(500).json({ error: 'Failed to promote template' });
  }
});
5. Frontend Implementation
Create public/js/ai-checklist.js:
javascript// AI Checklist Generation Functions

let currentPreview = null;

/**
 * Generate checklist from issue
 */
async function generateChecklistFromIssue() {
  const issueId = getIssueIdFromURL();
  
  if (!issueId) {
    showToast('No issue selected', 'error');
    return;
  }
  
  await generateChecklist('issue', issueId);
}

/**
 * Generate checklist from action item
 */
async function generateChecklistFromAction() {
  const actionId = getActionIdFromURL();
  
  if (!actionId) {
    showToast('No action item selected', 'error');
    return;
  }
  
  await generateChecklist('action-item', actionId);
}

/**
 * Generic generate function for both sources
 */
async function generateChecklist(sourceType, sourceId) {
  showAIGenerationModal(sourceType);
  
  const endpoint = sourceType === 'issue' 
    ? '/api/checklists/generate-from-issue'
    : '/api/checklists/generate-from-action';
  
  const bodyKey = sourceType === 'issue' ? 'issue_id' : 'action_id';
  
  try {
    const response = await fetch(endpoint, {
      method: 'POST',
      credentials: 'include',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ [bodyKey]: sourceId })
    });
    
    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.message || error.error || 'Generation failed');
    }
    
    currentPreview = await response.json();
    displayChecklistPreview(currentPreview);
    
  } catch (error) {
    console.error('Generation error:', error);
    hideAIGenerationModal();
    showToast(`Failed to generate checklist: ${error.message}`, 'error');
  }
}

/**
 * Show AI generation modal with loading state
 */
function showAIGenerationModal(sourceType) {
  let modal = document.getElementById('aiGenerationModal');
  
  if (!modal) {
    const modalHTML = `
      <div id="aiGenerationModal" class="modal">
        <div class="modal-content modal-large">
          <div class="modal-header">
            <h3>🤖 AI Checklist Generation</h3>
            <button onclick="hideAIGenerationModal()" class="close-btn">&times;</button>
          </div>
          <div id="aiModalBody" class="modal-body">
            <!-- Content will be inserted here -->
          </div>
        </div>
      </div>
    `;
    document.body.insertAdjacentHTML('beforeend', modalHTML);
    modal = document.getElementById('aiGenerationModal');
  }
  
  const sourceLabel = sourceType === 'issue' ? 'issue' : 'action item';
  
  document.getElementById('aiModalBody').innerHTML = `
    <div class="ai-loading">
      <div class="spinner"></div>
      <p>🧠 Analyzing ${sourceLabel} and generating checklist...</p>
      <p class="text-muted">This typically takes 10-30 seconds</p>
      <div class="loading-tips">
        <p><strong>What's happening:</strong></p>
        <ul>
          <li>📖 Reading ${sourceLabel} details</li>
          <li>🤔 Analyzing requirements</li>
          <li>📋 Creating checklist structure</li>
          <li>✨ Generating specific items</li>
        </ul>
      </div>
    </div>
  `;
  
  modal.style.display = 'block';
}

/**
 * Hide AI generation modal
 */
function hideAIGenerationModal() {
  const modal = document.getElementById('aiGenerationModal');
  if (modal) {
    modal.style.display = 'none';
  }
  currentPreview = null;
}

/**
 * Display checklist preview for user review
 */
function displayChecklistPreview(preview) {
  const totalItems = preview.sections.reduce((sum, section) => 
    sum + section.items.length, 0
  );
  
  const sourceLabel = preview.source_type === 'issue' ? 'Issue' : 'Action Item';
  const sourceIcon = preview.source_type === 'issue' ? '🐛' : '✅';
  
  const html = `
    <div class="preview-container">
      <div class="preview-header">
        <div class="preview-meta">
          <span class="badge badge-success">✨ AI Generated</span>
          <span class="badge badge-info">Confidence: ${preview.confidence}%</span>
          <span class="badge badge-secondary">${totalItems} items</span>
          <span class="badge badge-purple">${sourceIcon} From ${sourceLabel}</span>
        </div>
        <h4>${preview.title}</h4>
        <p>${preview.description}</p>
        
        <div class="preview-source">
          <strong>Source:</strong> ${preview.source_title}
        </div>
        
        ${preview.use_template ? 
          '<div class="alert alert-info">📋 Using existing template: <strong>Access Verification Checklist</strong></div>' : 
          '<div class="alert alert-warning">✨ Custom checklist generated specifically for this ' + sourceLabel.toLowerCase() + '</div>'
        }
        
        ${preview.rate_limit_remaining !== undefined ?
          `<div class="rate-limit-info">
            <small>💡 ${preview.rate_limit_remaining} AI generations remaining this hour</small>
          </div>` : ''
        }
      </div>
      
      <div class="preview-reasoning">
        <strong>🤔 AI Reasoning:</strong>
        <p>${preview.reasoning}</p>
      </div>
      
      <div class="preview-sections">
        <h5>📋 Checklist Structure Preview:</h5>
        ${preview.sections.map((section, idx) => `
          <div class="preview-section">
            <div class="section-header">
              <h6>${idx + 1}. ${section.title}</h6>
              <span class="item-count">${section.items.length} items</span>
            </div>
            ${section.description ? 
              `<p class="section-description">${section.description}</p>` : 
              ''
            }
            <ul class="preview-items">
              ${section.items.slice(0, 5).map(item => `
                <li>
                  <span class="field-type-badge field-type-${item.field_type}">${item.field_type}</span>
                  <span class="item-text">${item.text}</span>
                  ${item.is_required ? '<span class="required" title="Required">*</span>' : ''}
                  ${item.help_text ? `<div class="help-text">${item.help_text}</div>` : ''}
                </li>
              `).join('')}
              ${section.items.length > 5 ? 
                `<li class="more-items">
                  <span class="text-muted">... and ${section.items.length - 5} more items</span>
                </li>` : 
                ''
              }
            </ul>
          </div>
        `).join('')}
      </div>
      
      <div class="preview-actions">
        <button onclick="confirmGeneratedChecklist()" class="btn-primary btn-large">
          ✅ Create This Checklist
        </button>
        <button onclick="regenerateWithInstructions()" class="btn-secondary">
          🔄 Regenerate with Instructions
        </button>
        <button onclick="hideAIGenerationModal()" class="btn-secondary">
          ❌ Cancel
        </button>
      </div>
    </div>
  `;
  
  document.getElementById('aiModalBody').innerHTML = html;
}

/**
 * Confirm and create checklist from preview
 */
async function confirmGeneratedChecklist() {
  if (!currentPreview) {
    showToast('No preview available', 'error');
    return;
  }
  
  // Show saving state
  document.querySelector('.preview-actions').innerHTML = `
    <div class="saving-state">
      <div class="spinner-small"></div>
      <p>Creating checklist...</p>
    </div>
  `;
  
  try {
    const sourceId = currentPreview.issue_id || currentPreview.action_id;
    const sourceType = currentPreview.source_type;
    
    const response = await fetch('/api/checklists/confirm-generated', {
      method: 'POST',
      credentials: 'include',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        preview: currentPreview,
        source_id: sourceId,
        source_type: sourceType,
        project_id: currentPreview.project_id
      })
    });
    
    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.message || 'Failed to create checklist');
    }
    
    const result = await response.json();
    
    // Success!
    hideAIGenerationModal();
    showToast('✨ Checklist created successfully!', 'success');
    
    // Show promotion option if new template was created
    if (result.is_new_template) {
      setTimeout(() => {
        if (confirm('Would you like to save this as a reusable template for future use?')) {
          promoteTemplate(result.template_id);
        }
      }, 2000);
    }
    
    // Redirect to checklist
    setTimeout(() => {
      window.location.href = `/checklist-fill.html?id=${result.checklist.id}`;
    }, 1500);
    
  } catch (error) {
    console.error('Confirmation error:', error);
    showToast(`Failed to create checklist: ${error.message}`, 'error');
    
    // Restore buttons
    displayChecklistPreview(currentPreview);
  }
}

/**
 * Regenerate with custom instructions
 */
function regenerateWithInstructions() {
  // TODO: Show input for custom instructions, then regenerate
  showToast('Custom instructions feature coming soon!', 'info');
}

/**
 * Promote AI template to reusable
 */
async function promoteTemplate(templateId) {
  try {
    const response = await fetch(`/api/templates/${templateId}/promote`, {
      method: 'POST',
      credentials: 'include'
    });
    
    if (!response.ok) {
      throw new Error('Failed to promote template');
    }
    
    showToast('✨ Template saved for future use!', 'success');
    
  } catch (error) {
    console.error('Promotion error:', error);
    showToast('Could not save template', 'error');
  }
}

/**
 * Helper: Get issue ID from URL
 */
function getIssueIdFromURL() {
  const params = new URLSearchParams(window.location.search);
  return params.get('id') || params.get('issue_id');
}

/**
 * Helper: Get action ID from URL
 */
function getActionIdFromURL() {
  const params = new URLSearchParams(window.location.search);
  return params.get('id') || params.get('action_id');
}

/**
 * Helper: Show toast notification
 */
function showToast(message, type = 'info') {
  // Remove existing toasts
  document.querySelectorAll('.toast').forEach(t => t.remove());
  
  const toast = document.createElement('div');
  toast.className = `toast toast-${type}`;
  toast.innerHTML = `
    <div class="toast-content">
      ${type === 'success' ? '✅' : type === 'error' ? '❌' : 'ℹ️'}
      <span>${message}</span>
    </div>
  `;
  document.body.appendChild(toast);
  
  setTimeout(() => {
    toast.classList.add('show');
  }, 100);
  
  setTimeout(() => {
    toast.classList.remove('show');
    setTimeout(() => toast.remove(), 300);
  }, 4000);
}
Update issues.html (or issue detail page):
html<!-- Add button to issue detail view -->
<div class="issue-actions">
  <!-- Existing buttons -->
  <button onclick="generateChecklistFromIssue()" class="btn-ai">
    🤖 Generate Checklist
  </button>
</div>

<!-- Add script -->
<script src="js/ai-checklist.js"></script>
Update action-items.html (or action detail page):
html<!-- Add button to action item detail view -->
<div class="action-actions">
  <!-- Existing buttons -->
  <button onclick="generateChecklistFromAction()" class="btn-ai">
    🤖 Generate Checklist
  </button>
</div>

<!-- Add script -->
<script src="js/ai-checklist.js"></script>
6. CSS Styling
Add to public/css/checklists.css:
css/* AI Generation Styles */
.btn-ai {
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  border: none;
  padding: 10px 20px;
  border-radius: 8px;
  cursor: pointer;
  font-weight: 600;
  font-size: 14px;
  transition: all 0.3s;
  box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
}

.btn-ai:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 16px rgba(102, 126, 234, 0.5);
}

.modal-large {
  max-width: 900px;
  max-height: 90vh;
  overflow-y: auto;
}

.ai-loading {
  text-align: center;
  padding: 60px 40px;
}

.spinner {
  border: 4px solid #f3f3f3;
  border-top: 4px solid #667eea;
  border-radius: 50%;
  width: 60px;
  height: 60px;
  animation: spin 1s linear infinite;
  margin: 0 auto 25px;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

.loading-tips {
  margin-top: 30px;
  text-align: left;
  max-width: 400px;
  margin-left: auto;
  margin-right: auto;
  padding: 20px;
  background: #f8f9fa;
  border-radius: 8px;
}

.loading-tips ul {
  list-style: none;
  padding: 0;
  margin: 10px 0 0 0;
}

.loading-tips li {
  padding: 8px 0;
  color: #6b7280;
}

.preview-container {
  padding: 0;
}

.preview-header {
  padding: 25px;
  background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
  border-radius: 12px;
  margin-bottom: 25px;
}

.preview-meta {
  display: flex;
  gap: 10px;
  margin-bottom: 20px;
  flex-wrap: wrap;
}

.badge {
  padding: 6px 14px;
  border-radius: 16px;
  font-size: 12px;
  font-weight: 600;
  letter-spacing: 0.5px;
}

.badge-success { background: #10b981; color: white; }
.badge-info { background: #3b82f6; color: white; }
.badge-secondary { background: #6b7280; color: white; }
.badge-warning { background: #f59e0b; color: white; }
.badge-purple { background: #8b5cf6; color: white; }

.preview-source {
  margin-top: 15px;
  padding: 12px;
  background: white;
  border-radius: 6px;
  font-size: 14px;
}

.alert {
  padding: 12px 16px;
  border-radius: 8px;
  margin-top: 15px;
  font-size: 14px;
}

.alert-info {
  background: #dbeafe;
  border-left: 4px solid #3b82f6;
  color: #1e40af;
}

.alert-warning {
  background: #fef3c7;
  border-left: 4px solid #f59e0b;
  color: #92400e;
}

.rate-limit-info {
  margin-top: 10px;
  color: #6b7280;
}

.preview-reasoning {
  padding: 20px;
  background: #fffbeb;
  border-left: 4px solid #f59e0b;
  margin-bottom: 25px;
  border-radius: 8px;
}

.preview-sections {
  margin: 25px 0;
}

.preview-sections h5 {
  margin-bottom: 20px;
  color: #1f2937;
  font-size: 18px;
}

.preview-section {
  padding: 20px;
  background: white;
  border: 2px solid #e5e7eb;
  border-radius: 10px;
  margin-bottom: 20px;
  transition: all 0.2s;
}

.preview-section:hover {
  border-color: #667eea;
  box-shadow: 0 2px 8px rgba(102, 126, 234, 0.1);
}

.section-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 10px;
}

.section-header h6 {
  color: #1f2937;
  margin: 0;
  font-size: 16px;
}

.item-count {
  background: #e5e7eb;
  padding: 4px 12px;
  border-radius: 12px;
  font-size: 12px;
  font-weight: 600;
  color: #6b7280;
}

.section-description {
  color: #6b7280;
  font-size: 14px;
  margin: 8px 0 15px 0;
  font-style: italic;
}

.preview-items {
  list-style: none;
  padding: 0;
  margin: 0;
}

.preview-items li {
  padding: 12px 0;
  border-bottom: 1px solid #f3f4f6;
  display: flex;
  align-items: flex-start;
  gap: 12px;
}

.preview-items li:last-child {
  border-bottom: none;
}

.field-type-badge {
  display: inline-block;
  padding: 4px 10px;
  border-radius: 6px;
  font-size: 10px;
  font-weight: 700;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  flex-shrink: 0;
}

.field-type-checkbox { background: #dbeafe; color: #1e40af; }
.field-type-text { background: #d1fae5; color: #065f46; }
.field-type-textarea { background: #fef3c7; color: #92400e; }
.field-type-date { background: #fce7f3; color: #9f1239; }
.field-type-radio { background: #e9d5ff; color: #6b21a8; }

.item-text {
  flex: 1;
  color: #374151;
  line-height: 1.5;
}

.help-text {
  margin-top: 6px;
  padding: 8px 12px;
  background: #f9fafb;
  border-radius: 6px;
  font-size: 12px;
  color: #6b7280;
  font-style: italic;
}

.required {
  color: #ef4444;
  font-weight: bold;
  font-size: 16px;
  flex-shrink: 0;
}

.more-items {
  padding: 8px 0 !important;
  justify-content: center;
}

.preview-actions {
  display: flex;
  gap: 15px;
  justify-content: center;
  padding: 25px;
  border-top: 2px solid #e5e7eb;
  margin-top: 25px;
  background: #f9fafb;
  border-radius: 0 0 12px 12px;
}

.btn-large {
  padding: 14px 32px;
  font-size: 16px;
}

.saving-state {
  text-align: center;
  padding: 20px;
}

.spinner-small {
  border: 3px solid #f3f3f3;
  border-top: 3px solid #667eea;
  border-radius: 50%;
  width: 40px;
  height: 40px;
  animation: spin 1s linear infinite;
  margin: 0 auto 15px;
}

.toast {
  position: fixed;
  bottom: 30px;
  right: 30px;
  padding: 16px 24px;
  background: white;
  border-radius: 10px;
  box-shadow: 0 8px 24px rgba(0, 0, 0, 0.15);
  opacity: 0;
  transform: translateY(20px);
  transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
  z-index: 10000;
  min-width: 300px;
}

.toast.show {
  opacity: 1;
  transform: translateY(0);
}

.toast-content {
  display: flex;
  align-items: center;
  gap: 12px;
  font-size: 15px;
}

.toast-success {
  border-left: 4px solid #10b981;
}

.toast-error {
  border-left: 4px solid #ef4444;
}

.toast-info {
  border-left: 4px solid #3b82f6;
}

/* Responsive */
@media (max-width: 768px) {
  .modal-large {
    max-width: 95%;
    margin: 20px auto;
  }
  
  .preview-actions {
    flex-direction: column;
  }
  
  .preview-meta {
    justify-content: center;
  }
  
  .toast {
    right: 15px;
    left: 15px;
    bottom: 15px;
    min-width: auto;
  }
}

TESTING
After implementation, test with these scenarios:
Test 1: Generate from Issue

Navigate to any issue detail page
Click "🤖 Generate Checklist" button
Wait for AI generation
Review preview
Click "Create This Checklist"
Verify checklist created and linked to issue

Test 2: Generate from Action Item

Navigate to any action item detail page
Click "🤖 Generate Checklist" button
Wait for AI generation
Review preview
Click "Create This Checklist"
Verify checklist created and linked to action

Test 3: Template Promotion

After creating AI-generated checklist
When prompted, choose to save as reusable template
Go to template list
Verify template now appears

Test 4: Rate Limiting

Generate 10 checklists in quick succession
On 11th attempt, should see rate limit error
Wait 1 hour or check error message

Test 5: Template Filtering

Go to template list (GET /api/templates)
By default, should NOT see AI-generated non-reusable templates
Add ?include_ai_generated=true to URL
Now should see all templates including AI ones


CRITICAL REQUIREMENTS

✅ Database migrations run successfully
✅ AI API key configured in .env
✅ Both issue and action endpoints working
✅ Hybrid template approach implemented
✅ Rate limiting prevents abuse
✅ Template promotion feature working
✅ Template filtering hides non-reusable by default
✅ Error handling for AI failures
✅ Loading states shown during generation
✅ Checklists link to source (issue or action)


DELIVERABLES

✅ SQL migrations executed
✅ server/ai-service.js created
✅ API endpoints in server.js (4 new endpoints)
✅ public/js/ai-checklist.js created
✅ Generate buttons on issue and action pages
✅ AI generation modal functional
✅ Preview and confirmation flow working
✅ CSS styling applied
✅ Template promotion feature working
✅ Rate limiting implemented


OUTPUT REQUIRED
Confirm when complete:

"Database migrations successful" ✅
"AI service integrated with OpenAI/Anthropic" ✅
"Both issue and action endpoints working" ✅
"Hybrid template approach implemented" ✅
"Successfully generated checklists from both sources" ✅
"Template promotion tested" ✅
Fix error in Phase 3b Feature 1 mapping endpoints that's causing "Invalid template ID" error

CONTEXT:
- Phase 3b Feature 1 implementation is nearly complete
- Database migration successful, all tables created
- Service functions exist in server/template-service.js
- API endpoints exist in server.js
- Getting error "Invalid template ID" when calling GET /api/templates/issue-type-mappings

PROBLEM:
The mapping endpoints are failing when no projectId query parameter is provided. The error suggests an issue with SQL query parameter handling when projectId is null.

TASK:
Fix the SQL queries in template-service.js to properly handle null projectId parameter.

IMPLEMENTATION:

File: server/template-service.js

FIND the getIssueTypeTemplateMappings function (around line with this code):
```javascript
async function getIssueTypeTemplateMappings(projectId = null) {
  try {
    const result = await sql`
      SELECT 
        itt.*,
        ct.name as template_name,
        ct.description as template_description,
        ct.usage_count as template_usage_count
      FROM issue_type_templates itt
      LEFT JOIN checklist_templates ct ON itt.template_id = ct.id
      WHERE (itt.project_id = ${projectId} OR (itt.project_id IS NULL AND ${projectId} IS NULL))
        AND itt.is_active = TRUE
      ORDER BY itt.project_id NULLS LAST, itt.issue_type
    `;
    return result.rows;
  } catch (error) {
    console.error('Error fetching issue type mappings:', error);
    throw error;
  }
}
```

REPLACE with this corrected version using conditional SQL fragments:
```javascript
async function getIssueTypeTemplateMappings(projectId = null) {
  try {
    let result;
    
    if (projectId === null) {
      // Get all mappings when no project specified
      result = await sql`
        SELECT 
          itt.*,
          ct.name as template_name,
          ct.description as template_description,
          ct.usage_count as template_usage_count
        FROM issue_type_templates itt
        LEFT JOIN checklist_templates ct ON itt.template_id = ct.id
        WHERE itt.is_active = TRUE
        ORDER BY itt.project_id NULLS LAST, itt.issue_type
      `;
    } else {
      // Get mappings for specific project (including global ones)
      result = await sql`
        SELECT 
          itt.*,
          ct.name as template_name,
          ct.description as template_description,
          ct.usage_count as template_usage_count
        FROM issue_type_templates itt
        LEFT JOIN checklist_templates ct ON itt.template_id = ct.id
        WHERE (itt.project_id = ${projectId} OR itt.project_id IS NULL)
          AND itt.is_active = TRUE
        ORDER BY itt.project_id NULLS LAST, itt.issue_type
      `;
    }
    
    return result.rows;
  } catch (error) {
    console.error('Error fetching issue type mappings:', error);
    throw error;
  }
}
```

ALSO FIND the getActionCategoryTemplateMappings function:
```javascript
async function getActionCategoryTemplateMappings(projectId = null) {
  try {
    const result = await sql`
      SELECT 
        actt.*,
        ac.name as category_name,
        ac.description as category_description,
        ac.icon as category_icon,
        ct.name as template_name,
        ct.description as template_description,
        ct.usage_count as template_usage_count
      FROM action_item_category_templates actt
      LEFT JOIN action_item_categories ac ON actt.category_id = ac.id
      LEFT JOIN checklist_templates ct ON actt.template_id = ct.id
      WHERE (actt.project_id = ${projectId} OR (actt.project_id IS NULL AND ${projectId} IS NULL))
        AND actt.is_active = TRUE
      ORDER BY actt.project_id NULLS LAST, ac.display_order, ac.name
    `;
    return result.rows;
  } catch (error) {
    console.error('Error fetching action category mappings:', error);
    throw error;
  }
}
```

REPLACE with this corrected version:
```javascript
async function getActionCategoryTemplateMappings(projectId = null) {
  try {
    let result;
    
    if (projectId === null) {
      // Get all mappings when no project specified
      result = await sql`
        SELECT 
          actt.*,
          ac.name as category_name,
          ac.description as category_description,
          ac.icon as category_icon,
          ct.name as template_name,
          ct.description as template_description,
          ct.usage_count as template_usage_count
        FROM action_item_category_templates actt
        LEFT JOIN action_item_categories ac ON actt.category_id = ac.id
        LEFT JOIN checklist_templates ct ON actt.template_id = ct.id
        WHERE actt.is_active = TRUE
        ORDER BY actt.project_id NULLS LAST, ac.display_order, ac.name
      `;
    } else {
      // Get mappings for specific project (including global ones)
      result = await sql`
        SELECT 
          actt.*,
          ac.name as category_name,
          ac.description as category_description,
          ac.icon as category_icon,
          ct.name as template_name,
          ct.description as template_description,
          ct.usage_count as template_usage_count
        FROM action_item_category_templates actt
        LEFT JOIN action_item_categories ac ON actt.category_id = ac.id
        LEFT JOIN checklist_templates ct ON actt.template_id = ct.id
        WHERE (actt.project_id = ${projectId} OR actt.project_id IS NULL)
          AND actt.is_active = TRUE
        ORDER BY actt.project_id NULLS LAST, ac.display_order, ac.name
      `;
    }
    
    return result.rows;
  } catch (error) {
    console.error('Error fetching action category mappings:', error);
    throw error;
  }
}
```

EXPLANATION:
The issue is that @neondatabase/serverless SQL template literals don't handle NULL comparisons well in WHERE clauses like (column = ${null}). By splitting into two separate queries based on whether projectId is null, we avoid this issue:
- When projectId is null: fetch all mappings (no filtering by project)
- When projectId has a value: fetch mappings for that project OR global mappings (project_id IS NULL)

TESTING:
After making changes:

1. Restart server
2. Test endpoints:
   - GET http://localhost:3000/api/templates/issue-type-mappings
   - GET http://localhost:3000/api/templates/action-category-mappings

Expected results for both:
```json
[]
```
(Empty arrays since no mappings exist yet)

3. Test with project filter:
   - GET http://localhost:3000/api/templates/issue-type-mappings?projectId=1
   - GET http://localhost:3000/api/templates/action-category-mappings?projectId=1

Expected results:
```json
[]
```
(Still empty, but should NOT error)
CONTEXT:
Phase 2a - Prompt 2 of 3. AI Checklist Generation (Prompt 1) is complete and functional. Now implementing PDF export to generate professional reports from checklists.

TASK:
Add PDF export functionality to allow users to download completed checklists as professionally formatted PDF documents with progress charts, metadata, and sign-off sections.

ESTIMATED TIME: 3-4 hours

---

## REQUIREMENTS

### 1. Install Dependencies
```bash
# PDF generation library
npm install pdfkit

# Chart generation for progress visualization
npm install chart.js canvas

# Stream handling
npm install stream-buffers
```

### 2. Create PDF Service

**Create new file: server/pdf-service.js**
```javascript
const PDFDocument = require('pdfkit');
const { ChartJSNodeCanvas } = require('chartjs-node-canvas');
const streamBuffers = require('stream-buffers');

/**
 * Generate PDF from checklist data
 */
async function generateChecklistPDF(checklistData, options = {}) {
  const {
    format = 'full',              // 'full', 'summary', 'completed-only'
    include_comments = true,
    include_charts = true,
    include_metadata = true
  } = options;
  
  // Create PDF document
  const doc = new PDFDocument({
    size: 'LETTER',
    margins: {
      top: 50,
      bottom: 50,
      left: 50,
      right: 50
    },
    info: {
      Title: checklistData.title,
      Author: 'S4Carlisle Checklist System',
      Subject: 'Checklist Report',
      CreationDate: new Date()
    }
  });
  
  // Use stream buffer to capture PDF
  const outputBuffer = new streamBuffers.WritableStreamBuffer();
  doc.pipe(outputBuffer);
  
  try {
    // Header
    await addHeader(doc, checklistData);
    
    // Metadata section
    if (include_metadata) {
      await addMetadata(doc, checklistData);
    }
    
    // Progress chart
    if (include_charts) {
      await addProgressChart(doc, checklistData);
    }
    
    // Checklist sections and items
    await addChecklistContent(doc, checklistData, format, include_comments);
    
    // Sign-off section
    await addSignOffSection(doc, checklistData);
    
    // Footer on each page
    addPageNumbers(doc);
    
    // Finalize PDF
    doc.end();
    
    // Wait for PDF to finish
    await new Promise((resolve) => {
      outputBuffer.on('finish', resolve);
    });
    
    return outputBuffer.getContents();
    
  } catch (error) {
    console.error('PDF generation error:', error);
    throw new Error(`Failed to generate PDF: ${error.message}`);
  }
}

/**
 * Add header to PDF
 */
function addHeader(doc, checklistData) {
  // Title
  doc.fontSize(20)
     .fillColor('#1f2937')
     .font('Helvetica-Bold')
     .text(checklistData.title, { align: 'center' });
  
  doc.moveDown(0.5);
  
  // Subtitle with status badge
  const statusColors = {
    'not-started': '#6b7280',
    'in-progress': '#3b82f6',
    'completed': '#10b981',
    'approved': '#8b5cf6'
  };
  
  doc.fontSize(12)
     .fillColor(statusColors[checklistData.status] || '#6b7280')
     .font('Helvetica')
     .text(`Status: ${formatStatus(checklistData.status)}`, { align: 'center' });
  
  // Horizontal line
  doc.moveDown(1);
  doc.strokeColor('#e5e7eb')
     .lineWidth(1)
     .moveTo(50, doc.y)
     .lineTo(562, doc.y)
     .stroke();
  
  doc.moveDown(1);
  
  return doc;
}

/**
 * Add metadata section
 */
function addMetadata(doc, checklistData) {
  doc.fontSize(14)
     .fillColor('#1f2937')
     .font('Helvetica-Bold')
     .text('Checklist Information');
  
  doc.moveDown(0.5);
  
  // Metadata table
  const metadata = [
    { label: 'Checklist ID:', value: checklistData.checklist_id },
    { label: 'Project:', value: checklistData.project_name },
    { label: 'Template:', value: checklistData.template_name },
    { label: 'Created By:', value: checklistData.created_by_name },
    { label: 'Created On:', value: formatDate(checklistData.created_at) },
    { label: 'Last Updated:', value: formatDate(checklistData.updated_at) },
    { label: 'Total Items:', value: checklistData.total_items },
    { label: 'Completed Items:', value: checklistData.completed_items },
    { label: 'Completion:', value: `${checklistData.completion_percentage}%` }
  ];
  
  // Add AI generation info if applicable
  if (checklistData.is_ai_generated) {
    metadata.push({
      label: 'Generated By:',
      value: `AI from ${checklistData.generation_source === 'issue' ? 'Issue' : 'Action Item'}`
    });
    
    if (checklistData.source_title) {
      metadata.push({
        label: 'Source:',
        value: checklistData.source_title
      });
    }
  }
  
  doc.fontSize(10)
     .fillColor('#374151')
     .font('Helvetica');
  
  metadata.forEach(item => {
    doc.font('Helvetica-Bold').text(item.label, 70, doc.y, { continued: true, width: 150 });
    doc.font('Helvetica').text(item.value, { width: 350 });
    doc.moveDown(0.3);
  });
  
  doc.moveDown(1);
  
  return doc;
}

/**
 * Add progress chart
 */
async function addProgressChart(doc, checklistData) {
  try {
    const width = 500;
    const height = 200;
    
    // Create chart
    const chartCallback = (ChartJS) => {
      ChartJS.defaults.font.family = 'Helvetica';
    };
    
    const chartJSNodeCanvas = new ChartJSNodeCanvas({ 
      width, 
      height, 
      chartCallback 
    });
    
    const completed = checklistData.completed_items;
    const remaining = checklistData.total_items - completed;
    
    const configuration = {
      type: 'doughnut',
      data: {
        labels: ['Completed', 'Remaining'],
        datasets: [{
          data: [completed, remaining],
          backgroundColor: ['#10b981', '#e5e7eb'],
          borderWidth: 0
        }]
      },
      options: {
        responsive: true,
        plugins: {
          legend: {
            position: 'bottom',
            labels: {
              font: { size: 12 },
              padding: 15
            }
          },
          title: {
            display: true,
            text: 'Checklist Progress',
            font: { size: 16, weight: 'bold' },
            padding: { bottom: 20 }
          }
        }
      }
    };
    
    const imageBuffer = await chartJSNodeCanvas.renderToBuffer(configuration);
    
    // Add chart to PDF
    doc.image(imageBuffer, 80, doc.y, { width: 450, align: 'center' });
    doc.moveDown(8); // Space after chart
    
  } catch (error) {
    console.error('Chart generation error:', error);
    // Continue without chart
    doc.fontSize(10)
       .fillColor('#6b7280')
       .text('[Chart generation unavailable]', { align: 'center' });
    doc.moveDown(1);
  }
  
  return doc;
}

/**
 * Add checklist content (sections and items)
 */
async function addChecklistContent(doc, checklistData, format, includeComments) {
  doc.fontSize(14)
     .fillColor('#1f2937')
     .font('Helvetica-Bold')
     .text('Checklist Items');
  
  doc.moveDown(1);
  
  // Group items by section
  const sections = {};
  checklistData.items.forEach(item => {
    if (!sections[item.section_title]) {
      sections[item.section_title] = [];
    }
    sections[item.section_title].push(item);
  });
  
  // Iterate through sections
  for (const [sectionTitle, items] of Object.entries(sections)) {
    // Check if we need a new page
    if (doc.y > 650) {
      doc.addPage();
    }
    
    // Section header
    doc.fontSize(12)
       .fillColor('#1f2937')
       .font('Helvetica-Bold')
       .text(sectionTitle);
    
    doc.moveDown(0.5);
    
    // Items in section
    for (const item of items) {
      // Skip non-completed items if format is 'completed-only'
      if (format === 'completed-only' && !item.response_value) {
        continue;
      }
      
      // Check page space
      if (doc.y > 700) {
        doc.addPage();
      }
      
      // Item checkbox/bullet
      const isCompleted = !!item.response_value;
      const symbol = isCompleted ? '‚òë' : '‚òê';
      
      doc.fontSize(10)
         .fillColor('#374151')
         .font('Helvetica');
      
      // Item text with checkbox
      const itemY = doc.y;
      doc.text(symbol, 70, itemY, { continued: true, width: 15 });
      doc.text(item.item_text, { width: 450 });
      
      // Response value if exists
      if (item.response_value) {
        doc.moveDown(0.2);
        doc.fontSize(9)
           .fillColor('#6b7280')
           .font('Helvetica');
        
        const responseLabel = getFieldTypeLabel(item.field_type);
        doc.text(`${responseLabel}: ${formatResponseValue(item.response_value, item.field_type)}`, 85, doc.y);
      }
      
      // Comments if exist and included
      if (includeComments && item.comments && item.comments.length > 0) {
        doc.moveDown(0.2);
        doc.fontSize(8)
           .fillColor('#9ca3af')
           .font('Helvetica-Oblique')
           .text(`üí¨ ${item.comments.length} comment(s)`, 85, doc.y);
      }
      
      doc.moveDown(0.5);
    }
    
    doc.moveDown(0.5);
  }
  
  return doc;
}

/**
 * Add sign-off section
 */
function addSignOffSection(doc, checklistData) {
  // New page for sign-offs
  doc.addPage();
  
  doc.fontSize(14)
     .fillColor('#1f2937')
     .font('Helvetica-Bold')
     .text('Sign-Off & Approval');
  
  doc.moveDown(1);
  
  if (checklistData.signoffs && checklistData.signoffs.length > 0) {
    checklistData.signoffs.forEach(signoff => {
      // Sign-off box
      doc.rect(70, doc.y, 470, 100)
         .stroke('#e5e7eb');
      
      const boxY = doc.y;
      
      doc.fontSize(11)
         .fillColor('#1f2937')
         .font('Helvetica-Bold')
         .text(signoff.role, 80, boxY + 10);
      
      doc.fontSize(10)
         .fillColor('#374151')
         .font('Helvetica')
         .text(`Name: ${signoff.signed_by_name}`, 80, boxY + 30)
         .text(`Date: ${formatDate(signoff.signed_at)}`, 80, boxY + 45);
      
      if (signoff.status === 'approved') {
        doc.fillColor('#10b981')
           .text('‚úì APPROVED', 400, boxY + 30);
      } else if (signoff.status === 'rejected') {
        doc.fillColor('#ef4444')
           .text('‚úó REJECTED', 400, boxY + 30);
      }
      
      if (signoff.comments) {
        doc.fontSize(9)
           .fillColor('#6b7280')
           .text(`Comments: ${signoff.comments}`, 80, boxY + 65, { width: 450 });
      }
      
      doc.moveDown(7);
    });
  } else {
    // Placeholder for sign-offs
    doc.fontSize(10)
       .fillColor('#6b7280')
       .font('Helvetica')
       .text('No sign-offs recorded yet.', { align: 'center' });
    
    doc.moveDown(2);
    
    // Signature lines
    ['Technical Reviewer', 'Project Manager', 'Client Approval'].forEach((role, idx) => {
      const y = doc.y + (idx * 80);
      
      doc.fontSize(10)
         .fillColor('#374151')
         .font('Helvetica-Bold')
         .text(role, 70, y);
      
      // Signature line
      doc.moveTo(70, y + 40)
         .lineTo(270, y + 40)
         .stroke('#9ca3af');
      
      doc.fontSize(8)
         .fillColor('#9ca3af')
         .font('Helvetica')
         .text('Signature', 70, y + 45);
      
      // Date line
      doc.moveTo(320, y + 40)
         .lineTo(470, y + 40)
         .stroke('#9ca3af');
      
      doc.text('Date', 320, y + 45);
    });
  }
  
  return doc;
}

/**
 * Add page numbers
 */
function addPageNumbers(doc) {
  const pages = doc.bufferedPageRange();
  
  for (let i = 0; i < pages.count; i++) {
    doc.switchToPage(i);
    
    // Footer text
    doc.fontSize(8)
       .fillColor('#9ca3af')
       .font('Helvetica')
       .text(
         `Page ${i + 1} of ${pages.count} | Generated: ${formatDate(new Date())}`,
         50,
         doc.page.height - 40,
         { align: 'center', width: doc.page.width - 100 }
       );
  }
}

/**
 * Helper: Format status
 */
function formatStatus(status) {
  const statusMap = {
    'not-started': 'Not Started',
    'in-progress': 'In Progress',
    'completed': 'Completed',
    'approved': 'Approved'
  };
  return statusMap[status] || status;
}

/**
 * Helper: Format date
 */
function formatDate(date) {
  if (!date) return 'N/A';
  const d = new Date(date);
  return d.toLocaleDateString('en-US', { 
    year: 'numeric', 
    month: 'long', 
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit'
  });
}

/**
 * Helper: Get field type label
 */
function getFieldTypeLabel(fieldType) {
  const labels = {
    'checkbox': 'Checked',
    'text': 'Response',
    'textarea': 'Notes',
    'date': 'Date',
    'radio': 'Selection'
  };
  return labels[fieldType] || 'Value';
}

/**
 * Helper: Format response value
 */
function formatResponseValue(value, fieldType) {
  if (!value) return 'N/A';
  
  if (fieldType === 'checkbox') {
    return value === 'true' || value === true ? 'Yes' : 'No';
  }
  
  if (fieldType === 'date') {
    try {
      return new Date(value).toLocaleDateString('en-US');
    } catch (e) {
      return value;
    }
  }
  
  // Truncate long text
  if (typeof value === 'string' && value.length > 100) {
    return value.substring(0, 100) + '...';
  }
  
  return value;
}

module.exports = {
  generateChecklistPDF
};
```

### 3. API Endpoint

**Add to server.js:**
```javascript
const { generateChecklistPDF } = require('./server/pdf-service');

// ========================================
// PDF EXPORT ENDPOINT
// ========================================

// GET /api/checklists/:id/export/pdf - Export checklist as PDF
app.get('/api/checklists/:id/export/pdf', authenticateToken, async (req, res) => {
  try {
    const checklistId = req.params.id;
    const userId = req.user.id;
    
    const {
      format = 'full',              // 'full', 'summary', 'completed-only'
      include_comments = 'true',
      include_charts = 'true',
      include_metadata = 'true'
    } = req.query;
    
    // Get complete checklist data
    const checklistResult = await pool.query(
      `SELECT 
        c.*,
        ct.name as template_name,
        p.name as project_name,
        u.name as created_by_name,
        (SELECT COUNT(*) FROM checklist_responses cr
         INNER JOIN checklist_template_items cti ON cr.item_id = cti.id
         WHERE cr.checklist_id = c.id AND cr.response_value IS NOT NULL) as completed_items
      FROM checklists c
      LEFT JOIN checklist_templates ct ON c.template_id = ct.id
      LEFT JOIN projects p ON c.project_id = p.id
      LEFT JOIN users u ON c.created_by = u.id
      WHERE c.id = $1`,
      [checklistId]
    );
    
    if (checklistResult.rows.length === 0) {
      return res.status(404).json({ error: 'Checklist not found' });
    }
    
    const checklist = checklistResult.rows[0];
    
    // Check access
    const accessCheck = await pool.query(
      'SELECT 1 FROM project_members WHERE project_id = $1 AND user_id = $2',
      [checklist.project_id, userId]
    );
    
    if (accessCheck.rows.length === 0) {
      return res.status(403).json({ error: 'Access denied' });
    }
    
    // Calculate completion percentage
    checklist.completion_percentage = checklist.total_items > 0 
      ? Math.round((checklist.completed_items / checklist.total_items) * 100)
      : 0;
    
    // Get all items with responses
    const itemsResult = await pool.query(
      `SELECT 
        cti.id,
        cti.item_text,
        cti.field_type,
        cts.title as section_title,
        cts.section_number,
        cti.display_order,
        cr.response_value,
        cr.updated_at as response_date,
        (SELECT json_agg(json_build_object(
          'user', u.name,
          'comment', cc.comment_text,
          'created_at', cc.created_at
        ))
        FROM checklist_comments cc
        LEFT JOIN users u ON cc.user_id = u.id
        WHERE cc.checklist_id = $1 AND cc.item_id = cti.id) as comments
      FROM checklist_template_items cti
      INNER JOIN checklist_template_sections cts ON cti.section_id = cts.id
      LEFT JOIN checklist_responses cr ON cr.item_id = cti.id AND cr.checklist_id = $1
      WHERE cts.template_id = $2
      ORDER BY cts.display_order, cti.display_order`,
      [checklistId, checklist.template_id]
    );
    
    checklist.items = itemsResult.rows;
    
    // Get sign-offs
    const signoffsResult = await pool.query(
      `SELECT 
        cs.*,
        u.name as signed_by_name
      FROM checklist_signoffs cs
      LEFT JOIN users u ON cs.signed_by = u.id
      WHERE cs.checklist_id = $1
      ORDER BY cs.signed_at DESC`,
      [checklistId]
    );
    
    checklist.signoffs = signoffsResult.rows;
    
    // Get source information if AI-generated
    if (checklist.is_ai_generated) {
      if (checklist.generation_source === 'issue' && checklist.related_issue_id) {
        const issueResult = await pool.query(
          'SELECT title FROM issues WHERE id = $1',
          [checklist.related_issue_id]
        );
        if (issueResult.rows.length > 0) {
          checklist.source_title = issueResult.rows[0].title;
        }
      } else if (checklist.generation_source === 'action-item' && checklist.related_action_id) {
        const actionResult = await pool.query(
          'SELECT title FROM action_items WHERE id = $1',
          [checklist.related_action_id]
        );
        if (actionResult.rows.length > 0) {
          checklist.source_title = actionResult.rows[0].title;
        }
      }
    }
    
    // Generate PDF
    const pdfBuffer = await generateChecklistPDF(checklist, {
      format,
      include_comments: include_comments === 'true',
      include_charts: include_charts === 'true',
      include_metadata: include_metadata === 'true'
    });
    
    // Set response headers
    const filename = `${checklist.checklist_id || 'checklist'}_${Date.now()}.pdf`;
    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
    res.setHeader('Content-Length', pdfBuffer.length);
    
    // Send PDF
    res.send(pdfBuffer);
    
    // Log export
    console.log(`PDF exported: ${filename} by user ${userId}`);
    
  } catch (error) {
    console.error('PDF export error:', error);
    res.status(500).json({ 
      error: 'Failed to generate PDF',
      message: error.message 
    });
  }
});
```

### 4. Frontend Implementation

**Update public/js/checklist-detail.js (or create if doesn't exist):**
```javascript
/**
 * Export checklist as PDF
 */
async function exportChecklistPDF(checklistId, options = {}) {
  try {
    // Show loading state
    const exportBtn = document.getElementById('exportPdfBtn');
    const originalText = exportBtn.innerHTML;
    exportBtn.disabled = true;
    exportBtn.innerHTML = '‚è≥ Generating PDF...';
    
    // Build query params
    const params = new URLSearchParams({
      format: options.format || 'full',
      include_comments: options.include_comments !== false,
      include_charts: options.include_charts !== false,
      include_metadata: options.include_metadata !== false
    });
    
    // Fetch PDF
    const response = await fetch(`/api/checklists/${checklistId}/export/pdf?${params}`, {
      method: 'GET',
      credentials: 'include'
    });
    
    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.message || 'Export failed');
    }
    
    // Get filename from headers
    const contentDisposition = response.headers.get('Content-Disposition');
    const filenameMatch = contentDisposition?.match(/filename="(.+)"/);
    const filename = filenameMatch ? filenameMatch[1] : 'checklist.pdf';
    
    // Download PDF
    const blob = await response.blob();
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    window.URL.revokeObjectURL(url);
    document.body.removeChild(a);
    
    // Success
    showToast('‚úÖ PDF downloaded successfully!', 'success');
    
    // Restore button
    exportBtn.disabled = false;
    exportBtn.innerHTML = originalText;
    
  } catch (error) {
    console.error('Export error:', error);
    showToast(`‚ùå Export failed: ${error.message}`, 'error');
    
    // Restore button
    const exportBtn = document.getElementById('exportPdfBtn');
    if (exportBtn) {
      exportBtn.disabled = false;
      exportBtn.innerHTML = 'üì• Export PDF';
    }
  }
}

/**
 * Show export options modal
 */
function showExportOptionsModal(checklistId) {
  const modal = document.getElementById('exportOptionsModal') || createExportOptionsModal();
  
  modal.querySelector('.modal-body').innerHTML = `
    <div class="export-options">
      <h4>Export Options</h4>
      
      <div class="option-group">
        <label><strong>Export Format:</strong></label>
        <div class="radio-group">
          <label>
            <input type="radio" name="format" value="full" checked>
            Full Report (all items)
          </label>
          <label>
            <input type="radio" name="format" value="completed-only">
            Completed Items Only
          </label>
          <label>
            <input type="radio" name="format" value="summary">
            Summary (metadata + progress only)
          </label>
        </div>
      </div>
      
      <div class="option-group">
        <label><strong>Include:</strong></label>
        <div class="checkbox-group">
          <label>
            <input type="checkbox" id="includeComments" checked>
            Comments
          </label>
          <label>
            <input type="checkbox" id="includeCharts" checked>
            Progress Charts
          </label>
          <label>
            <input type="checkbox" id="includeMetadata" checked>
            Metadata Section
          </label>
        </div>
      </div>
      
      <div class="modal-actions">
        <button onclick="confirmExport(${checklistId})" class="btn-primary">
          üì• Download PDF
        </button>
        <button onclick="hideExportOptionsModal()" class="btn-secondary">
          Cancel
        </button>
      </div>
    </div>
  `;
  
  modal.style.display = 'block';
}

/**
 * Create export options modal
 */
function createExportOptionsModal() {
  const modalHTML = `
    <div id="exportOptionsModal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <h3>Export to PDF</h3>
          <button onclick="hideExportOptionsModal()" class="close-btn">&times;</button>
        </div>
        <div class="modal-body">
          <!-- Content inserted dynamically -->
        </div>
      </div>
    </div>
  `;
  document.body.insertAdjacentHTML('beforeend', modalHTML);
  return document.getElementById('exportOptionsModal');
}

/**
 * Hide export options modal
 */
function hideExportOptionsModal() {
  const modal = document.getElementById('exportOptionsModal');
  if (modal) {
    modal.style.display = 'none';
  }
}

/**
 * Confirm export with selected options
 */
function confirmExport(checklistId) {
  const format = document.querySelector('input[name="format"]:checked').value;
  const includeComments = document.getElementById('includeComments').checked;
  const includeCharts = document.getElementById('includeCharts').checked;
  const includeMetadata = document.getElementById('includeMetadata').checked;
  
  hideExportOptionsModal();
  
  exportChecklistPDF(checklistId, {
    format,
    include_comments: includeComments,
    include_charts: includeCharts,
    include_metadata: includeMetadata
  });
}

/**
 * Quick export with default options
 */
function quickExportPDF(checklistId) {
  exportChecklistPDF(checklistId, {
    format: 'full',
    include_comments: true,
    include_charts: true,
    include_metadata: true
  });
}
```

### 5. Add Export Button to UI

**Update checklist-fill.html or checklist-detail.html:**
```html
<!-- Add to header/toolbar area -->
<div class="checklist-actions">
  <!-- Existing buttons -->
  
  <!-- Simple export button -->
  <button onclick="quickExportPDF(currentChecklistId)" id="exportPdfBtn" class="btn-export">
    üì• Export PDF
  </button>
  
  <!-- OR with options dropdown -->
  <div class="dropdown">
    <button class="btn-export dropdown-toggle">
      üì• Export
    </button>
    <div class="dropdown-menu">
      <a href="#" onclick="quickExportPDF(currentChecklistId); return false;">
        Quick Export (Full Report)
      </a>
      <a href="#" onclick="showExportOptionsModal(currentChecklistId); return false;">
        Export with Options...
      </a>
    </div>
  </div>
</div>

<!-- Add script -->
<script src="js/checklist-detail.js"></script>
```

### 6. CSS Styling

**Add to public/css/checklists.css:**
```css
/* Export Button */
.btn-export {
  background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
  color: white;
  border: none;
  padding: 10px 20px;
  border-radius: 8px;
  cursor: pointer;
  font-weight: 600;
  font-size: 14px;
  transition: all 0.3s;
  box-shadow: 0 2px 8px rgba(239, 68, 68, 0.3);
}

.btn-export:hover:not(:disabled) {
  transform: translateY(-2px);
  box-shadow: 0 4px 16px rgba(239, 68, 68, 0.5);
}

.btn-export:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

/* Export Options Modal */
.export-options {
  padding: 20px;
}

.export-options h4 {
  margin-bottom: 20px;
  color: #1f2937;
}

.option-group {
  margin-bottom: 25px;
  padding: 15px;
  background: #f9fafb;
  border-radius: 8px;
}

.option-group label {
  display: block;
  margin-bottom: 10px;
  color: #1f2937;
}

.radio-group label,
.checkbox-group label {
  display: flex;
  align-items: center;
  padding: 8px 0;
  color: #374151;
  cursor: pointer;
}

.radio-group input[type="radio"],
.checkbox-group input[type="checkbox"] {
  margin-right: 10px;
  cursor: pointer;
}

/* Dropdown Menu */
.dropdown {
  position: relative;
  display: inline-block;
}

.dropdown-toggle {
  padding-right: 35px;
  position: relative;
}

.dropdown-toggle::after {
  content: '‚ñº';
  position: absolute;
  right: 15px;
  top: 50%;
  transform: translateY(-50%);
  font-size: 10px;
}

.dropdown-menu {
  display: none;
  position: absolute;
  top: 100%;
  left: 0;
  background: white;
  border: 1px solid #e5e7eb;
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  min-width: 200px;
  z-index: 1000;
  margin-top: 5px;
}

.dropdown:hover .dropdown-menu {
  display: block;
}

.dropdown-menu a {
  display: block;
  padding: 12px 16px;
  color: #374151;
  text-decoration: none;
  transition: background 0.2s;
}

.dropdown-menu a:hover {
  background: #f3f4f6;
}

.dropdown-menu a:first-child {
  border-radius: 8px 8px 0 0;
}

.dropdown-menu a:last-child {
  border-radius: 0 0 8px 8px;
}
```

---

## TESTING

**Test Scenarios:**

1. **Basic Export:**
   - Click "Export PDF" on any checklist
   - Verify PDF downloads
   - Open PDF and check formatting

2. **Different Formats:**
   - Export as "Full Report"
   - Export as "Completed Only"
   - Export as "Summary"
   - Verify each shows correct content

3. **Options Testing:**
   - Toggle "Include Comments" off
   - Toggle "Include Charts" off
   - Toggle "Include Metadata" off
   - Verify PDF respects options

4. **AI-Generated Checklist:**
   - Export an AI-generated checklist
   - Verify metadata shows "Generated by AI"
   - Verify source information included

5. **Large Checklist:**
   - Export the 303-item Access Verification checklist
   - Verify all sections included
   - Verify pagination works correctly

6. **Empty Checklist:**
   - Export checklist with no responses
   - Verify it doesn't crash
   - Verify shows "no responses yet"

7. **Sign-offs:**
   - Export checklist with sign-offs
   - Verify sign-offs appear
   - Export checklist without sign-offs
   - Verify placeholder signature lines appear

8. **Performance:**
   - Export should complete in <5 seconds
   - File size should be <5MB for typical checklist

---

## CRITICAL REQUIREMENTS

1. ‚úÖ PDF downloads correctly in browser
2. ‚úÖ All checklist data included
3. ‚úÖ Progress chart displays correctly
4. ‚úÖ Sign-off section present
5. ‚úÖ Page numbers on all pages
6. ‚úÖ Professional formatting
7. ‚úÖ AI metadata shown when applicable
8. ‚úÖ Export options work as expected
9. ‚úÖ Error handling for generation failures
10. ‚úÖ Works on mobile browsers

---

## DELIVERABLES

1. ‚úÖ server/pdf-service.js created with full PDF generation
2. ‚úÖ PDF export endpoint in server.js
3. ‚úÖ Frontend export functions in checklist-detail.js
4. ‚úÖ Export button added to checklist pages
5. ‚úÖ Export options modal functional
6. ‚úÖ CSS styling for export UI
7. ‚úÖ Chart generation working
8. ‚úÖ All export formats working
9. ‚úÖ Error handling complete
10. ‚úÖ Successfully exported PDFs tested

---

## KNOWN LIMITATIONS

- Charts require canvas package (may need additional config on some systems)
- Large checklists (>1000 items) may take >5 seconds
- Image attachments not embedded in PDF (Phase 2b feature)
- Custom branding not yet implemented (Phase 2b)

---

## OUTPUT REQUIRED

Confirm when complete:
1. "PDF service created and tested" ‚úÖ
2. "Export endpoint working" ‚úÖ
3. "Export button on checklist pages" ‚úÖ
4. "Options modal functional" ‚úÖ
5. "Successfully exported PDFs from multiple checklists" ‚úÖ
6. "All export formats tested" ‚úÖ

Let me know when ready to test!

This prompt implements:

‚úÖ Full PDF generation with PDFKit
‚úÖ Progress charts with Chart.js
‚úÖ Multiple export formats (full/summary/completed)
‚úÖ Export options modal
‚úÖ AI generation metadata in PDFs
‚úÖ Sign-off section (with placeholders if none exist)
‚úÖ Professional formatting with page numbers
‚úÖ Works for any checklist status
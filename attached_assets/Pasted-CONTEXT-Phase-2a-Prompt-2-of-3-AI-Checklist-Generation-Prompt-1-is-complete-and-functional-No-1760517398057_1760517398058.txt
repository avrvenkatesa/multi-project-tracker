CONTEXT:
Phase 2a - Prompt 2 of 3. AI Checklist Generation (Prompt 1) is complete and functional. Now implementing PDF export to generate professional reports from checklists.

TASK:
Add PDF export functionality to allow users to download completed checklists as professionally formatted PDF documents with progress charts, metadata, and sign-off sections.

ESTIMATED TIME: 3-4 hours

---

## REQUIREMENTS

### 1. Install Dependencies
```bash
# PDF generation library
npm install pdfkit

# Chart generation for progress visualization
npm install chart.js canvas

# Stream handling
npm install stream-buffers
```

### 2. Create PDF Service

**Create new file: server/pdf-service.js**
```javascript
const PDFDocument = require('pdfkit');
const { ChartJSNodeCanvas } = require('chartjs-node-canvas');
const streamBuffers = require('stream-buffers');

/**
 * Generate PDF from checklist data
 */
async function generateChecklistPDF(checklistData, options = {}) {
  const {
    format = 'full',              // 'full', 'summary', 'completed-only'
    include_comments = true,
    include_charts = true,
    include_metadata = true
  } = options;
  
  // Create PDF document
  const doc = new PDFDocument({
    size: 'LETTER',
    margins: {
      top: 50,
      bottom: 50,
      left: 50,
      right: 50
    },
    info: {
      Title: checklistData.title,
      Author: 'S4Carlisle Checklist System',
      Subject: 'Checklist Report',
      CreationDate: new Date()
    }
  });
  
  // Use stream buffer to capture PDF
  const outputBuffer = new streamBuffers.WritableStreamBuffer();
  doc.pipe(outputBuffer);
  
  try {
    // Header
    await addHeader(doc, checklistData);
    
    // Metadata section
    if (include_metadata) {
      await addMetadata(doc, checklistData);
    }
    
    // Progress chart
    if (include_charts) {
      await addProgressChart(doc, checklistData);
    }
    
    // Checklist sections and items
    await addChecklistContent(doc, checklistData, format, include_comments);
    
    // Sign-off section
    await addSignOffSection(doc, checklistData);
    
    // Footer on each page
    addPageNumbers(doc);
    
    // Finalize PDF
    doc.end();
    
    // Wait for PDF to finish
    await new Promise((resolve) => {
      outputBuffer.on('finish', resolve);
    });
    
    return outputBuffer.getContents();
    
  } catch (error) {
    console.error('PDF generation error:', error);
    throw new Error(`Failed to generate PDF: ${error.message}`);
  }
}

/**
 * Add header to PDF
 */
function addHeader(doc, checklistData) {
  // Title
  doc.fontSize(20)
     .fillColor('#1f2937')
     .font('Helvetica-Bold')
     .text(checklistData.title, { align: 'center' });
  
  doc.moveDown(0.5);
  
  // Subtitle with status badge
  const statusColors = {
    'not-started': '#6b7280',
    'in-progress': '#3b82f6',
    'completed': '#10b981',
    'approved': '#8b5cf6'
  };
  
  doc.fontSize(12)
     .fillColor(statusColors[checklistData.status] || '#6b7280')
     .font('Helvetica')
     .text(`Status: ${formatStatus(checklistData.status)}`, { align: 'center' });
  
  // Horizontal line
  doc.moveDown(1);
  doc.strokeColor('#e5e7eb')
     .lineWidth(1)
     .moveTo(50, doc.y)
     .lineTo(562, doc.y)
     .stroke();
  
  doc.moveDown(1);
  
  return doc;
}

/**
 * Add metadata section
 */
function addMetadata(doc, checklistData) {
  doc.fontSize(14)
     .fillColor('#1f2937')
     .font('Helvetica-Bold')
     .text('Checklist Information');
  
  doc.moveDown(0.5);
  
  // Metadata table
  const metadata = [
    { label: 'Checklist ID:', value: checklistData.checklist_id },
    { label: 'Project:', value: checklistData.project_name },
    { label: 'Template:', value: checklistData.template_name },
    { label: 'Created By:', value: checklistData.created_by_name },
    { label: 'Created On:', value: formatDate(checklistData.created_at) },
    { label: 'Last Updated:', value: formatDate(checklistData.updated_at) },
    { label: 'Total Items:', value: checklistData.total_items },
    { label: 'Completed Items:', value: checklistData.completed_items },
    { label: 'Completion:', value: `${checklistData.completion_percentage}%` }
  ];
  
  // Add AI generation info if applicable
  if (checklistData.is_ai_generated) {
    metadata.push({
      label: 'Generated By:',
      value: `AI from ${checklistData.generation_source === 'issue' ? 'Issue' : 'Action Item'}`
    });
    
    if (checklistData.source_title) {
      metadata.push({
        label: 'Source:',
        value: checklistData.source_title
      });
    }
  }
  
  doc.fontSize(10)
     .fillColor('#374151')
     .font('Helvetica');
  
  metadata.forEach(item => {
    doc.font('Helvetica-Bold').text(item.label, 70, doc.y, { continued: true, width: 150 });
    doc.font('Helvetica').text(item.value, { width: 350 });
    doc.moveDown(0.3);
  });
  
  doc.moveDown(1);
  
  return doc;
}

/**
 * Add progress chart
 */
async function addProgressChart(doc, checklistData) {
  try {
    const width = 500;
    const height = 200;
    
    // Create chart
    const chartCallback = (ChartJS) => {
      ChartJS.defaults.font.family = 'Helvetica';
    };
    
    const chartJSNodeCanvas = new ChartJSNodeCanvas({ 
      width, 
      height, 
      chartCallback 
    });
    
    const completed = checklistData.completed_items;
    const remaining = checklistData.total_items - completed;
    
    const configuration = {
      type: 'doughnut',
      data: {
        labels: ['Completed', 'Remaining'],
        datasets: [{
          data: [completed, remaining],
          backgroundColor: ['#10b981', '#e5e7eb'],
          borderWidth: 0
        }]
      },
      options: {
        responsive: true,
        plugins: {
          legend: {
            position: 'bottom',
            labels: {
              font: { size: 12 },
              padding: 15
            }
          },
          title: {
            display: true,
            text: 'Checklist Progress',
            font: { size: 16, weight: 'bold' },
            padding: { bottom: 20 }
          }
        }
      }
    };
    
    const imageBuffer = await chartJSNodeCanvas.renderToBuffer(configuration);
    
    // Add chart to PDF
    doc.image(imageBuffer, 80, doc.y, { width: 450, align: 'center' });
    doc.moveDown(8); // Space after chart
    
  } catch (error) {
    console.error('Chart generation error:', error);
    // Continue without chart
    doc.fontSize(10)
       .fillColor('#6b7280')
       .text('[Chart generation unavailable]', { align: 'center' });
    doc.moveDown(1);
  }
  
  return doc;
}

/**
 * Add checklist content (sections and items)
 */
async function addChecklistContent(doc, checklistData, format, includeComments) {
  doc.fontSize(14)
     .fillColor('#1f2937')
     .font('Helvetica-Bold')
     .text('Checklist Items');
  
  doc.moveDown(1);
  
  // Group items by section
  const sections = {};
  checklistData.items.forEach(item => {
    if (!sections[item.section_title]) {
      sections[item.section_title] = [];
    }
    sections[item.section_title].push(item);
  });
  
  // Iterate through sections
  for (const [sectionTitle, items] of Object.entries(sections)) {
    // Check if we need a new page
    if (doc.y > 650) {
      doc.addPage();
    }
    
    // Section header
    doc.fontSize(12)
       .fillColor('#1f2937')
       .font('Helvetica-Bold')
       .text(sectionTitle);
    
    doc.moveDown(0.5);
    
    // Items in section
    for (const item of items) {
      // Skip non-completed items if format is 'completed-only'
      if (format === 'completed-only' && !item.response_value) {
        continue;
      }
      
      // Check page space
      if (doc.y > 700) {
        doc.addPage();
      }
      
      // Item checkbox/bullet
      const isCompleted = !!item.response_value;
      const symbol = isCompleted ? '☑' : '☐';
      
      doc.fontSize(10)
         .fillColor('#374151')
         .font('Helvetica');
      
      // Item text with checkbox
      const itemY = doc.y;
      doc.text(symbol, 70, itemY, { continued: true, width: 15 });
      doc.text(item.item_text, { width: 450 });
      
      // Response value if exists
      if (item.response_value) {
        doc.moveDown(0.2);
        doc.fontSize(9)
           .fillColor('#6b7280')
           .font('Helvetica');
        
        const responseLabel = getFieldTypeLabel(item.field_type);
        doc.text(`${responseLabel}: ${formatResponseValue(item.response_value, item.field_type)}`, 85, doc.y);
      }
      
      // Comments if exist and included
      if (includeComments && item.comments && item.comments.length > 0) {
        doc.moveDown(0.2);
        doc.fontSize(8)
           .fillColor('#9ca3af')
           .font('Helvetica-Oblique')
           .text(`💬 ${item.comments.length} comment(s)`, 85, doc.y);
      }
      
      doc.moveDown(0.5);
    }
    
    doc.moveDown(0.5);
  }
  
  return doc;
}

/**
 * Add sign-off section
 */
function addSignOffSection(doc, checklistData) {
  // New page for sign-offs
  doc.addPage();
  
  doc.fontSize(14)
     .fillColor('#1f2937')
     .font('Helvetica-Bold')
     .text('Sign-Off & Approval');
  
  doc.moveDown(1);
  
  if (checklistData.signoffs && checklistData.signoffs.length > 0) {
    checklistData.signoffs.forEach(signoff => {
      // Sign-off box
      doc.rect(70, doc.y, 470, 100)
         .stroke('#e5e7eb');
      
      const boxY = doc.y;
      
      doc.fontSize(11)
         .fillColor('#1f2937')
         .font('Helvetica-Bold')
         .text(signoff.role, 80, boxY + 10);
      
      doc.fontSize(10)
         .fillColor('#374151')
         .font('Helvetica')
         .text(`Name: ${signoff.signed_by_name}`, 80, boxY + 30)
         .text(`Date: ${formatDate(signoff.signed_at)}`, 80, boxY + 45);
      
      if (signoff.status === 'approved') {
        doc.fillColor('#10b981')
           .text('✓ APPROVED', 400, boxY + 30);
      } else if (signoff.status === 'rejected') {
        doc.fillColor('#ef4444')
           .text('✗ REJECTED', 400, boxY + 30);
      }
      
      if (signoff.comments) {
        doc.fontSize(9)
           .fillColor('#6b7280')
           .text(`Comments: ${signoff.comments}`, 80, boxY + 65, { width: 450 });
      }
      
      doc.moveDown(7);
    });
  } else {
    // Placeholder for sign-offs
    doc.fontSize(10)
       .fillColor('#6b7280')
       .font('Helvetica')
       .text('No sign-offs recorded yet.', { align: 'center' });
    
    doc.moveDown(2);
    
    // Signature lines
    ['Technical Reviewer', 'Project Manager', 'Client Approval'].forEach((role, idx) => {
      const y = doc.y + (idx * 80);
      
      doc.fontSize(10)
         .fillColor('#374151')
         .font('Helvetica-Bold')
         .text(role, 70, y);
      
      // Signature line
      doc.moveTo(70, y + 40)
         .lineTo(270, y + 40)
         .stroke('#9ca3af');
      
      doc.fontSize(8)
         .fillColor('#9ca3af')
         .font('Helvetica')
         .text('Signature', 70, y + 45);
      
      // Date line
      doc.moveTo(320, y + 40)
         .lineTo(470, y + 40)
         .stroke('#9ca3af');
      
      doc.text('Date', 320, y + 45);
    });
  }
  
  return doc;
}

/**
 * Add page numbers
 */
function addPageNumbers(doc) {
  const pages = doc.bufferedPageRange();
  
  for (let i = 0; i < pages.count; i++) {
    doc.switchToPage(i);
    
    // Footer text
    doc.fontSize(8)
       .fillColor('#9ca3af')
       .font('Helvetica')
       .text(
         `Page ${i + 1} of ${pages.count} | Generated: ${formatDate(new Date())}`,
         50,
         doc.page.height - 40,
         { align: 'center', width: doc.page.width - 100 }
       );
  }
}

/**
 * Helper: Format status
 */
function formatStatus(status) {
  const statusMap = {
    'not-started': 'Not Started',
    'in-progress': 'In Progress',
    'completed': 'Completed',
    'approved': 'Approved'
  };
  return statusMap[status] || status;
}

/**
 * Helper: Format date
 */
function formatDate(date) {
  if (!date) return 'N/A';
  const d = new Date(date);
  return d.toLocaleDateString('en-US', { 
    year: 'numeric', 
    month: 'long', 
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit'
  });
}

/**
 * Helper: Get field type label
 */
function getFieldTypeLabel(fieldType) {
  const labels = {
    'checkbox': 'Checked',
    'text': 'Response',
    'textarea': 'Notes',
    'date': 'Date',
    'radio': 'Selection'
  };
  return labels[fieldType] || 'Value';
}

/**
 * Helper: Format response value
 */
function formatResponseValue(value, fieldType) {
  if (!value) return 'N/A';
  
  if (fieldType === 'checkbox') {
    return value === 'true' || value === true ? 'Yes' : 'No';
  }
  
  if (fieldType === 'date') {
    try {
      return new Date(value).toLocaleDateString('en-US');
    } catch (e) {
      return value;
    }
  }
  
  // Truncate long text
  if (typeof value === 'string' && value.length > 100) {
    return value.substring(0, 100) + '...';
  }
  
  return value;
}

module.exports = {
  generateChecklistPDF
};
```

### 3. API Endpoint

**Add to server.js:**
```javascript
const { generateChecklistPDF } = require('./server/pdf-service');

// ========================================
// PDF EXPORT ENDPOINT
// ========================================

// GET /api/checklists/:id/export/pdf - Export checklist as PDF
app.get('/api/checklists/:id/export/pdf', authenticateToken, async (req, res) => {
  try {
    const checklistId = req.params.id;
    const userId = req.user.id;
    
    const {
      format = 'full',              // 'full', 'summary', 'completed-only'
      include_comments = 'true',
      include_charts = 'true',
      include_metadata = 'true'
    } = req.query;
    
    // Get complete checklist data
    const checklistResult = await pool.query(
      `SELECT 
        c.*,
        ct.name as template_name,
        p.name as project_name,
        u.name as created_by_name,
        (SELECT COUNT(*) FROM checklist_responses cr
         INNER JOIN checklist_template_items cti ON cr.item_id = cti.id
         WHERE cr.checklist_id = c.id AND cr.response_value IS NOT NULL) as completed_items
      FROM checklists c
      LEFT JOIN checklist_templates ct ON c.template_id = ct.id
      LEFT JOIN projects p ON c.project_id = p.id
      LEFT JOIN users u ON c.created_by = u.id
      WHERE c.id = $1`,
      [checklistId]
    );
    
    if (checklistResult.rows.length === 0) {
      return res.status(404).json({ error: 'Checklist not found' });
    }
    
    const checklist = checklistResult.rows[0];
    
    // Check access
    const accessCheck = await pool.query(
      'SELECT 1 FROM project_members WHERE project_id = $1 AND user_id = $2',
      [checklist.project_id, userId]
    );
    
    if (accessCheck.rows.length === 0) {
      return res.status(403).json({ error: 'Access denied' });
    }
    
    // Calculate completion percentage
    checklist.completion_percentage = checklist.total_items > 0 
      ? Math.round((checklist.completed_items / checklist.total_items) * 100)
      : 0;
    
    // Get all items with responses
    const itemsResult = await pool.query(
      `SELECT 
        cti.id,
        cti.item_text,
        cti.field_type,
        cts.title as section_title,
        cts.section_number,
        cti.display_order,
        cr.response_value,
        cr.updated_at as response_date,
        (SELECT json_agg(json_build_object(
          'user', u.name,
          'comment', cc.comment_text,
          'created_at', cc.created_at
        ))
        FROM checklist_comments cc
        LEFT JOIN users u ON cc.user_id = u.id
        WHERE cc.checklist_id = $1 AND cc.item_id = cti.id) as comments
      FROM checklist_template_items cti
      INNER JOIN checklist_template_sections cts ON cti.section_id = cts.id
      LEFT JOIN checklist_responses cr ON cr.item_id = cti.id AND cr.checklist_id = $1
      WHERE cts.template_id = $2
      ORDER BY cts.display_order, cti.display_order`,
      [checklistId, checklist.template_id]
    );
    
    checklist.items = itemsResult.rows;
    
    // Get sign-offs
    const signoffsResult = await pool.query(
      `SELECT 
        cs.*,
        u.name as signed_by_name
      FROM checklist_signoffs cs
      LEFT JOIN users u ON cs.signed_by = u.id
      WHERE cs.checklist_id = $1
      ORDER BY cs.signed_at DESC`,
      [checklistId]
    );
    
    checklist.signoffs = signoffsResult.rows;
    
    // Get source information if AI-generated
    if (checklist.is_ai_generated) {
      if (checklist.generation_source === 'issue' && checklist.related_issue_id) {
        const issueResult = await pool.query(
          'SELECT title FROM issues WHERE id = $1',
          [checklist.related_issue_id]
        );
        if (issueResult.rows.length > 0) {
          checklist.source_title = issueResult.rows[0].title;
        }
      } else if (checklist.generation_source === 'action-item' && checklist.related_action_id) {
        const actionResult = await pool.query(
          'SELECT title FROM action_items WHERE id = $1',
          [checklist.related_action_id]
        );
        if (actionResult.rows.length > 0) {
          checklist.source_title = actionResult.rows[0].title;
        }
      }
    }
    
    // Generate PDF
    const pdfBuffer = await generateChecklistPDF(checklist, {
      format,
      include_comments: include_comments === 'true',
      include_charts: include_charts === 'true',
      include_metadata: include_metadata === 'true'
    });
    
    // Set response headers
    const filename = `${checklist.checklist_id || 'checklist'}_${Date.now()}.pdf`;
    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader('Content-Disposition', `attachment; filename="${filename}"`);
    res.setHeader('Content-Length', pdfBuffer.length);
    
    // Send PDF
    res.send(pdfBuffer);
    
    // Log export
    console.log(`PDF exported: ${filename} by user ${userId}`);
    
  } catch (error) {
    console.error('PDF export error:', error);
    res.status(500).json({ 
      error: 'Failed to generate PDF',
      message: error.message 
    });
  }
});
```

### 4. Frontend Implementation

**Update public/js/checklist-detail.js (or create if doesn't exist):**
```javascript
/**
 * Export checklist as PDF
 */
async function exportChecklistPDF(checklistId, options = {}) {
  try {
    // Show loading state
    const exportBtn = document.getElementById('exportPdfBtn');
    const originalText = exportBtn.innerHTML;
    exportBtn.disabled = true;
    exportBtn.innerHTML = '⏳ Generating PDF...';
    
    // Build query params
    const params = new URLSearchParams({
      format: options.format || 'full',
      include_comments: options.include_comments !== false,
      include_charts: options.include_charts !== false,
      include_metadata: options.include_metadata !== false
    });
    
    // Fetch PDF
    const response = await fetch(`/api/checklists/${checklistId}/export/pdf?${params}`, {
      method: 'GET',
      credentials: 'include'
    });
    
    if (!response.ok) {
      const error = await response.json();
      throw new Error(error.message || 'Export failed');
    }
    
    // Get filename from headers
    const contentDisposition = response.headers.get('Content-Disposition');
    const filenameMatch = contentDisposition?.match(/filename="(.+)"/);
    const filename = filenameMatch ? filenameMatch[1] : 'checklist.pdf';
    
    // Download PDF
    const blob = await response.blob();
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    window.URL.revokeObjectURL(url);
    document.body.removeChild(a);
    
    // Success
    showToast('✅ PDF downloaded successfully!', 'success');
    
    // Restore button
    exportBtn.disabled = false;
    exportBtn.innerHTML = originalText;
    
  } catch (error) {
    console.error('Export error:', error);
    showToast(`❌ Export failed: ${error.message}`, 'error');
    
    // Restore button
    const exportBtn = document.getElementById('exportPdfBtn');
    if (exportBtn) {
      exportBtn.disabled = false;
      exportBtn.innerHTML = '📥 Export PDF';
    }
  }
}

/**
 * Show export options modal
 */
function showExportOptionsModal(checklistId) {
  const modal = document.getElementById('exportOptionsModal') || createExportOptionsModal();
  
  modal.querySelector('.modal-body').innerHTML = `
    <div class="export-options">
      <h4>Export Options</h4>
      
      <div class="option-group">
        <label><strong>Export Format:</strong></label>
        <div class="radio-group">
          <label>
            <input type="radio" name="format" value="full" checked>
            Full Report (all items)
          </label>
          <label>
            <input type="radio" name="format" value="completed-only">
            Completed Items Only
          </label>
          <label>
            <input type="radio" name="format" value="summary">
            Summary (metadata + progress only)
          </label>
        </div>
      </div>
      
      <div class="option-group">
        <label><strong>Include:</strong></label>
        <div class="checkbox-group">
          <label>
            <input type="checkbox" id="includeComments" checked>
            Comments
          </label>
          <label>
            <input type="checkbox" id="includeCharts" checked>
            Progress Charts
          </label>
          <label>
            <input type="checkbox" id="includeMetadata" checked>
            Metadata Section
          </label>
        </div>
      </div>
      
      <div class="modal-actions">
        <button onclick="confirmExport(${checklistId})" class="btn-primary">
          📥 Download PDF
        </button>
        <button onclick="hideExportOptionsModal()" class="btn-secondary">
          Cancel
        </button>
      </div>
    </div>
  `;
  
  modal.style.display = 'block';
}

/**
 * Create export options modal
 */
function createExportOptionsModal() {
  const modalHTML = `
    <div id="exportOptionsModal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <h3>Export to PDF</h3>
          <button onclick="hideExportOptionsModal()" class="close-btn">&times;</button>
        </div>
        <div class="modal-body">
          <!-- Content inserted dynamically -->
        </div>
      </div>
    </div>
  `;
  document.body.insertAdjacentHTML('beforeend', modalHTML);
  return document.getElementById('exportOptionsModal');
}

/**
 * Hide export options modal
 */
function hideExportOptionsModal() {
  const modal = document.getElementById('exportOptionsModal');
  if (modal) {
    modal.style.display = 'none';
  }
}

/**
 * Confirm export with selected options
 */
function confirmExport(checklistId) {
  const format = document.querySelector('input[name="format"]:checked').value;
  const includeComments = document.getElementById('includeComments').checked;
  const includeCharts = document.getElementById('includeCharts').checked;
  const includeMetadata = document.getElementById('includeMetadata').checked;
  
  hideExportOptionsModal();
  
  exportChecklistPDF(checklistId, {
    format,
    include_comments: includeComments,
    include_charts: includeCharts,
    include_metadata: includeMetadata
  });
}

/**
 * Quick export with default options
 */
function quickExportPDF(checklistId) {
  exportChecklistPDF(checklistId, {
    format: 'full',
    include_comments: true,
    include_charts: true,
    include_metadata: true
  });
}
```

### 5. Add Export Button to UI

**Update checklist-fill.html or checklist-detail.html:**
```html
<!-- Add to header/toolbar area -->
<div class="checklist-actions">
  <!-- Existing buttons -->
  
  <!-- Simple export button -->
  <button onclick="quickExportPDF(currentChecklistId)" id="exportPdfBtn" class="btn-export">
    📥 Export PDF
  </button>
  
  <!-- OR with options dropdown -->
  <div class="dropdown">
    <button class="btn-export dropdown-toggle">
      📥 Export
    </button>
    <div class="dropdown-menu">
      <a href="#" onclick="quickExportPDF(currentChecklistId); return false;">
        Quick Export (Full Report)
      </a>
      <a href="#" onclick="showExportOptionsModal(currentChecklistId); return false;">
        Export with Options...
      </a>
    </div>
  </div>
</div>

<!-- Add script -->
<script src="js/checklist-detail.js"></script>
```

### 6. CSS Styling

**Add to public/css/checklists.css:**
```css
/* Export Button */
.btn-export {
  background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
  color: white;
  border: none;
  padding: 10px 20px;
  border-radius: 8px;
  cursor: pointer;
  font-weight: 600;
  font-size: 14px;
  transition: all 0.3s;
  box-shadow: 0 2px 8px rgba(239, 68, 68, 0.3);
}

.btn-export:hover:not(:disabled) {
  transform: translateY(-2px);
  box-shadow: 0 4px 16px rgba(239, 68, 68, 0.5);
}

.btn-export:disabled {
  opacity: 0.6;
  cursor: not-allowed;
}

/* Export Options Modal */
.export-options {
  padding: 20px;
}

.export-options h4 {
  margin-bottom: 20px;
  color: #1f2937;
}

.option-group {
  margin-bottom: 25px;
  padding: 15px;
  background: #f9fafb;
  border-radius: 8px;
}

.option-group label {
  display: block;
  margin-bottom: 10px;
  color: #1f2937;
}

.radio-group label,
.checkbox-group label {
  display: flex;
  align-items: center;
  padding: 8px 0;
  color: #374151;
  cursor: pointer;
}

.radio-group input[type="radio"],
.checkbox-group input[type="checkbox"] {
  margin-right: 10px;
  cursor: pointer;
}

/* Dropdown Menu */
.dropdown {
  position: relative;
  display: inline-block;
}

.dropdown-toggle {
  padding-right: 35px;
  position: relative;
}

.dropdown-toggle::after {
  content: '▼';
  position: absolute;
  right: 15px;
  top: 50%;
  transform: translateY(-50%);
  font-size: 10px;
}

.dropdown-menu {
  display: none;
  position: absolute;
  top: 100%;
  left: 0;
  background: white;
  border: 1px solid #e5e7eb;
  border-radius: 8px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
  min-width: 200px;
  z-index: 1000;
  margin-top: 5px;
}

.dropdown:hover .dropdown-menu {
  display: block;
}

.dropdown-menu a {
  display: block;
  padding: 12px 16px;
  color: #374151;
  text-decoration: none;
  transition: background 0.2s;
}

.dropdown-menu a:hover {
  background: #f3f4f6;
}

.dropdown-menu a:first-child {
  border-radius: 8px 8px 0 0;
}

.dropdown-menu a:last-child {
  border-radius: 0 0 8px 8px;
}
```

---

## TESTING

**Test Scenarios:**

1. **Basic Export:**
   - Click "Export PDF" on any checklist
   - Verify PDF downloads
   - Open PDF and check formatting

2. **Different Formats:**
   - Export as "Full Report"
   - Export as "Completed Only"
   - Export as "Summary"
   - Verify each shows correct content

3. **Options Testing:**
   - Toggle "Include Comments" off
   - Toggle "Include Charts" off
   - Toggle "Include Metadata" off
   - Verify PDF respects options

4. **AI-Generated Checklist:**
   - Export an AI-generated checklist
   - Verify metadata shows "Generated by AI"
   - Verify source information included

5. **Large Checklist:**
   - Export the 303-item Access Verification checklist
   - Verify all sections included
   - Verify pagination works correctly

6. **Empty Checklist:**
   - Export checklist with no responses
   - Verify it doesn't crash
   - Verify shows "no responses yet"

7. **Sign-offs:**
   - Export checklist with sign-offs
   - Verify sign-offs appear
   - Export checklist without sign-offs
   - Verify placeholder signature lines appear

8. **Performance:**
   - Export should complete in <5 seconds
   - File size should be <5MB for typical checklist

---

## CRITICAL REQUIREMENTS

1. ✅ PDF downloads correctly in browser
2. ✅ All checklist data included
3. ✅ Progress chart displays correctly
4. ✅ Sign-off section present
5. ✅ Page numbers on all pages
6. ✅ Professional formatting
7. ✅ AI metadata shown when applicable
8. ✅ Export options work as expected
9. ✅ Error handling for generation failures
10. ✅ Works on mobile browsers

---

## DELIVERABLES

1. ✅ server/pdf-service.js created with full PDF generation
2. ✅ PDF export endpoint in server.js
3. ✅ Frontend export functions in checklist-detail.js
4. ✅ Export button added to checklist pages
5. ✅ Export options modal functional
6. ✅ CSS styling for export UI
7. ✅ Chart generation working
8. ✅ All export formats working
9. ✅ Error handling complete
10. ✅ Successfully exported PDFs tested

---

## KNOWN LIMITATIONS

- Charts require canvas package (may need additional config on some systems)
- Large checklists (>1000 items) may take >5 seconds
- Image attachments not embedded in PDF (Phase 2b feature)
- Custom branding not yet implemented (Phase 2b)

---

## OUTPUT REQUIRED

Confirm when complete:
1. "PDF service created and tested" ✅
2. "Export endpoint working" ✅
3. "Export button on checklist pages" ✅
4. "Options modal functional" ✅
5. "Successfully exported PDFs from multiple checklists" ✅
6. "All export formats tested" ✅

Let me know when ready to test!

This prompt implements:

✅ Full PDF generation with PDFKit
✅ Progress charts with Chart.js
✅ Multiple export formats (full/summary/completed)
✅ Export options modal
✅ AI generation metadata in PDFs
✅ Sign-off section (with placeholders if none exist)
✅ Professional formatting with page numbers
✅ Works for any checklist status
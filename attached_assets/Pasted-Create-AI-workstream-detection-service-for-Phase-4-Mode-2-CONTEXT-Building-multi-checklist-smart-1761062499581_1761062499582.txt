Create AI workstream detection service for Phase 4 Mode 2

CONTEXT:
- Building multi-checklist smart matching feature
- Need AI to identify distinct work areas in large documents
- Each work area gets its own focused checklist
- Foundation for matching checklists to issues
- Working on branch: feature/phase4-mode2-smart-matching

TASK:
Create service that analyzes documents and identifies discrete workstreams/phases.

IMPLEMENTATION:

Part 1: Create Workstream Detection Service

File: services/workstream-detector.js
```javascript
// services/workstream-detector.js
// Phase 4 Mode 2: Workstream Detection for Multi-Checklist Generation

const openai = require('./ai-client'); // Use your existing OpenAI client setup

/**
 * Analyze document and identify distinct workstreams
 * @param {string} documentText - Full document text
 * @param {object} context - Project context
 * @returns {object} Identified workstreams with metadata
 */
async function detectWorkstreams(documentText, context) {
  console.log('üîç Analyzing document for workstreams...');
  
  try {
    // Truncate if needed (AI token limits)
    const maxLength = 30000; // Larger for comprehensive analysis
    const text = documentText.length > maxLength 
      ? documentText.substring(0, maxLength) + '\n\n[Document truncated for analysis...]'
      : documentText;
    
    const prompt = buildWorkstreamDetectionPrompt(text, context);
    
    // Use existing AI client (adapt to your setup)
    const response = await openai.chat.completions.create({
      model: 'gpt-4o', // Use best model for analysis
      messages: [
        {
          role: 'system',
          content: 'You are an expert project analyst specializing in document analysis and work breakdown structure. You identify distinct, non-overlapping work areas in project documents.'
        },
        {
          role: 'user',
          content: prompt
        }
      ],
      temperature: 0.5, // Lower temperature for more consistent analysis
      max_tokens: 3000
    });
    
    const rawResponse = response.choices[0].message.content;
    
    console.log('üìÑ Raw AI response length:', rawResponse.length);
    
    // Parse response
    const parsed = parseWorkstreamResponse(rawResponse);
    
    console.log(`‚úÖ Identified ${parsed.workstreams.length} workstreams`);
    
    return {
      success: true,
      workstreams: parsed.workstreams,
      summary: parsed.summary,
      documentLength: documentText.length,
      tokensUsed: response.usage?.total_tokens || 0
    };
    
  } catch (error) {
    console.error('Error detecting workstreams:', error);
    throw error;
  }
}

/**
 * Build AI prompt for workstream detection
 */
function buildWorkstreamDetectionPrompt(documentText, context) {
  return `Analyze this document and identify distinct work areas, phases, or workstreams.

PROJECT CONTEXT:
- Project: ${context.projectName || 'Unknown'}
- Document: ${context.documentFilename || 'Unknown'}
${context.projectDescription ? `- Description: ${context.projectDescription}` : ''}

DOCUMENT CONTENT:
${documentText}

TASK:
Identify 3-10 distinct workstreams or work areas from this document. Each workstream should represent a logically separate area of work that could be managed independently.

GUIDELINES:
1. Look for natural divisions: phases, components, functional areas, deliverables, stages
2. Each workstream should be substantial enough for 5-15 actionable tasks
3. Avoid excessive granularity - combine related small sections
4. Avoid overlapping workstreams - each should be distinct and non-redundant
5. Use clear, descriptive names (e.g., "Infrastructure Setup and Configuration", not "Section 1" or "Phase 1")
6. Extract key information and requirements for each workstream from the document
7. Identify logical dependencies (which workstreams should be completed before others)

OUTPUT FORMAT (JSON):
{
  "workstreams": [
    {
      "id": "workstream-1",
      "name": "Clear descriptive name (e.g., 'Infrastructure Assessment and Planning')",
      "description": "2-3 sentence description of this work area and its scope",
      "documentSections": ["Section 2.1: Current State Analysis", "Section 2.3: Infrastructure Inventory"],
      "keyRequirements": [
        "Specific requirement or deliverable 1",
        "Specific requirement or deliverable 2",
        "Specific requirement or deliverable 3"
      ],
      "estimatedComplexity": "low" | "medium" | "high",
      "dependencies": ["workstream-2"], 
      "suggestedPhase": "Planning" | "Implementation" | "Testing" | "Deployment" | "Post-Deployment"
    }
  ],
  "summary": {
    "totalWorkstreams": 5,
    "documentType": "SOW" | "Requirements Document" | "Technical Specification" | "Project Plan" | "Other",
    "overallScope": "2-3 sentence summary of the overall document scope and purpose"
  }
}

CRITICAL RULES:
- Return ONLY valid JSON (no markdown, no code blocks, no explanations)
- Each workstream MUST be distinct and substantial
- Each workstream MUST have at least 3 keyRequirements
- Dependencies must reference valid workstream IDs
- Minimum 3 workstreams, maximum 10 workstreams

Analyze the document now and return the JSON.`;
}

/**
 * Parse AI response into structured workstreams
 */
function parseWorkstreamResponse(rawResponse) {
  try {
    // Remove markdown code blocks if present
    let jsonText = rawResponse.trim();
    jsonText = jsonText.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
    
    const parsed = JSON.parse(jsonText);
    
    if (!parsed.workstreams || !Array.isArray(parsed.workstreams)) {
      throw new Error('Invalid workstream structure from AI - missing workstreams array');
    }
    
    // Validate and clean workstreams
    const workstreams = parsed.workstreams
      .filter(ws => {
        if (!ws.name || !ws.description) {
          console.warn('Skipping workstream without name or description');
          return false;
        }
        return true;
      })
      .map((ws, index) => ({
        id: ws.id || `workstream-${index + 1}`,
        name: ws.name.trim(),
        description: ws.description.trim(),
        documentSections: Array.isArray(ws.documentSections) ? ws.documentSections : [],
        keyRequirements: Array.isArray(ws.keyRequirements) ? ws.keyRequirements : [],
        estimatedComplexity: ['low', 'medium', 'high'].includes(ws.estimatedComplexity) 
          ? ws.estimatedComplexity 
          : 'medium',
        dependencies: Array.isArray(ws.dependencies) ? ws.dependencies : [],
        suggestedPhase: ws.suggestedPhase || 'Implementation'
      }));
    
    if (workstreams.length === 0) {
      throw new Error('No valid workstreams generated by AI');
    }
    
    if (workstreams.length < 3) {
      console.warn(`Only ${workstreams.length} workstreams generated, expected at least 3`);
    }
    
    // Limit to reasonable number
    if (workstreams.length > 10) {
      console.warn(`Too many workstreams (${workstreams.length}), limiting to 10`);
      workstreams.splice(10);
    }
    
    const summary = {
      totalWorkstreams: workstreams.length,
      documentType: parsed.summary?.documentType || 'Unknown',
      overallScope: parsed.summary?.overallScope || 'Document analysis completed'
    };
    
    return {
      workstreams,
      summary
    };
    
  } catch (error) {
    console.error('Error parsing workstream response:', error);
    console.error('Raw response preview:', rawResponse.substring(0, 500));
    
    // Try to provide helpful error message
    if (error instanceof SyntaxError) {
      throw new Error(`AI returned invalid JSON: ${error.message}`);
    }
    
    throw new Error(`Failed to parse AI workstream response: ${error.message}`);
  }
}

/**
 * Generate checklists for identified workstreams
 * @param {array} workstreams - Detected workstreams
 * @param {string} documentText - Original document
 * @returns {array} Generated checklists with workstream metadata
 */
async function generateChecklistsForWorkstreams(workstreams, documentText) {
  console.log(`üìã Generating checklists for ${workstreams.length} workstreams...`);
  
  const checklists = [];
  
  for (const workstream of workstreams) {
    try {
      console.log(`  ‚Üí Generating checklist for: ${workstream.name}`);
      const checklist = await generateWorkstreamChecklist(workstream, documentText);
      
      checklists.push({
        workstreamId: workstream.id,
        workstreamName: workstream.name,
        workstreamDescription: workstream.description,
        estimatedComplexity: workstream.estimatedComplexity,
        suggestedPhase: workstream.suggestedPhase,
        checklist: checklist
      });
      
      console.log(`  ‚úì Generated ${checklist.sections?.reduce((sum, s) => sum + (s.items?.length || 0), 0) || 0} items`);
      
    } catch (error) {
      console.error(`  ‚úó Error generating checklist for ${workstream.name}:`, error);
      // Continue with other workstreams
    }
  }
  
  console.log(`‚úÖ Generated ${checklists.length}/${workstreams.length} checklists successfully`);
  
  return checklists;
}

/**
 * Generate single checklist for a workstream
 */
async function generateWorkstreamChecklist(workstream, documentText) {
  const prompt = `Generate a focused, actionable checklist for this specific work area.

WORKSTREAM DETAILS:
Name: ${workstream.name}
Description: ${workstream.description}
Phase: ${workstream.suggestedPhase}
Complexity: ${workstream.estimatedComplexity}

Key Requirements:
${workstream.keyRequirements.map((req, i) => `${i + 1}. ${req}`).join('\n')}

Document Sections Referenced:
${workstream.documentSections.join('\n')}

FULL DOCUMENT (for context):
${documentText.substring(0, 15000)}

TASK:
Generate a checklist with 5-15 actionable items specifically for the "${workstream.name}" workstream.

REQUIREMENTS:
1. Items must be specific to THIS workstream only (not general or overlapping with other workstreams)
2. Start each item with an action verb (Review, Implement, Configure, Test, Verify, Document, etc.)
3. Include relevant document section references in notes where applicable
4. Order items logically based on dependencies and workflow
5. Make items specific, measurable, and achievable
6. Group related items into logical sections (e.g., Planning, Execution, Validation)

OUTPUT FORMAT (JSON):
{
  "title": "${workstream.name} Checklist",
  "description": "Brief 1-2 sentence description of this checklist's purpose",
  "sections": [
    {
      "title": "Section name (e.g., 'Planning', 'Execution', 'Validation', 'Documentation')",
      "items": [
        {
          "text": "Specific actionable task with clear outcome",
          "notes": "Context, document reference (e.g., 'Per Section 2.1'), or additional details",
          "priority": "high" | "medium" | "low"
        }
      ]
    }
  ]
}

CRITICAL RULES:
- Return ONLY valid JSON (no markdown, no code blocks)
- Must have at least 2 sections
- Each section must have at least 2 items
- Total items must be between 5-15
- Items must be actionable and specific to this workstream

Generate the checklist now and return the JSON.`;

  const response = await openai.chat.completions.create({
    model: 'gpt-4o',
    messages: [
      {
        role: 'system',
        content: 'You are a project management expert creating focused, actionable checklists for specific work areas. Each checklist item should be clear, measurable, and achievable.'
      },
      {
        role: 'user',
        content: prompt
      }
    ],
    temperature: 0.7,
    max_tokens: 2000
  });
  
  const rawResponse = response.choices[0].message.content;
  
  // Parse checklist
  let jsonText = rawResponse.trim();
  jsonText = jsonText.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
  
  const checklist = JSON.parse(jsonText);
  
  // Validate structure
  if (!checklist.sections || !Array.isArray(checklist.sections)) {
    throw new Error('Generated checklist missing sections array');
  }
  
  if (checklist.sections.length === 0) {
    throw new Error('Generated checklist has no sections');
  }
  
  // Validate each section has items
  const validSections = checklist.sections.filter(section => {
    if (!section.items || !Array.isArray(section.items) || section.items.length === 0) {
      console.warn(`Removing empty section: ${section.title}`);
      return false;
    }
    return true;
  });
  
  if (validSections.length === 0) {
    throw new Error('Generated checklist has no valid sections with items');
  }
  
  checklist.sections = validSections;
  
  // Count total items
  const totalItems = checklist.sections.reduce((sum, s) => sum + s.items.length, 0);
  
  if (totalItems === 0) {
    throw new Error('Generated checklist has zero items');
  }
  
  console.log(`    ‚Üí Checklist has ${checklist.sections.length} sections, ${totalItems} items`);
  
  return checklist;
}

module.exports = {
  detectWorkstreams,
  generateChecklistsForWorkstreams,
  generateWorkstreamChecklist
};
```

Part 2: Add API Endpoints

Add to server.js:
```javascript
// ============================================
// Phase 4 Mode 2: Workstream Detection & Generation
// ============================================

const workstreamDetector = require('./services/workstream-detector.js');

/**
 * Analyze document and detect workstreams
 * POST /api/projects/:projectId/analyze-workstreams
 * Body: { documentText: string, filename: string }
 */
app.post('/api/projects/:projectId/analyze-workstreams', async (req, res) => {
  try {
    const { projectId } = req.params;
    const { documentText, filename } = req.body;
    
    if (!documentText) {
      return res.status(400).json({ 
        error: 'Document text required',
        message: 'Please provide documentText in request body'
      });
    }
    
    // Get project info
    const projectResult = await pool.query(
      'SELECT id, name, description FROM projects WHERE id = $1',
      [projectId]
    );
    
    if (projectResult.rows.length === 0) {
      return res.status(404).json({ error: 'Project not found' });
    }
    
    const project = projectResult.rows[0];
    
    console.log(`üîç Analyzing workstreams for project: ${project.name}`);
    
    // Detect workstreams
    const result = await workstreamDetector.detectWorkstreams(documentText, {
      projectId: parseInt(projectId),
      projectName: project.name,
      projectDescription: project.description,
      documentFilename: filename
    });
    
    res.json({
      success: true,
      workstreams: result.workstreams,
      summary: result.summary,
      metadata: {
        documentLength: result.documentLength,
        tokensUsed: result.tokensUsed,
        workstreamCount: result.workstreams.length
      }
    });
    
  } catch (error) {
    console.error('Workstream detection error:', error);
    res.status(500).json({
      error: 'Failed to detect workstreams',
      message: error.message
    });
  }
});

/**
 * Generate checklists for detected workstreams
 * POST /api/projects/:projectId/generate-workstream-checklists
 * Body: { workstreams: array, documentText: string }
 */
app.post('/api/projects/:projectId/generate-workstream-checklists', async (req, res) => {
  try {
    const { projectId } = req.params;
    const { workstreams, documentText } = req.body;
    
    if (!workstreams || !Array.isArray(workstreams)) {
      return res.status(400).json({ 
        error: 'Workstreams array required',
        message: 'Please provide workstreams array in request body'
      });
    }
    
    if (!documentText) {
      return res.status(400).json({
        error: 'Document text required',
        message: 'Please provide documentText for context'
      });
    }
    
    console.log(`üìã Generating checklists for ${workstreams.length} workstreams`);
    
    // Generate checklists
    const checklists = await workstreamDetector.generateChecklistsForWorkstreams(
      workstreams,
      documentText
    );
    
    res.json({
      success: true,
      checklists: checklists,
      count: checklists.length,
      totalItems: checklists.reduce((sum, c) => {
        return sum + (c.checklist.sections?.reduce(
          (s, sec) => s + (sec.items?.length || 0), 0
        ) || 0);
      }, 0)
    });
    
  } catch (error) {
    console.error('Checklist generation error:', error);
    res.status(500).json({
      error: 'Failed to generate checklists',
      message: error.message
    });
  }
});
```

Part 3: Testing Script

Create test to verify workstream detection:
```javascript
// Test in browser console or create test file

async function testWorkstreamDetection() {
  const testDoc = `
Azure Cloud Migration - Statement of Work

1. INFRASTRUCTURE ASSESSMENT (Weeks 1-2)
Objective: Document current on-premises infrastructure
- Complete inventory of all servers and applications
- Network topology mapping
- Storage capacity and IOPS analysis
- Identify dependencies between systems
- Document backup and disaster recovery setup

2. MIGRATION PLANNING (Weeks 2-3)
Objective: Develop comprehensive migration strategy
- Define migration waves and priorities
- Establish timeline and milestones
- Identify potential risks and mitigation strategies
- Plan for parallel operation during cutover
- Create rollback procedures

3. AZURE ENVIRONMENT SETUP (Weeks 3-4)
Objective: Configure Azure infrastructure
- Design Azure resource groups and subscriptions
- Configure virtual networks and subnets
- Set up ExpressRoute or VPN connectivity
- Implement Azure Active Directory integration
- Configure monitoring and alerting

4. APPLICATION MIGRATION (Weeks 4-6)
Objective: Migrate applications to Azure
- Install Azure Migration Service tools
- Perform lift-and-shift migration for VMs
- Migrate databases to Azure SQL or Managed Instance
- Update application configurations for cloud
- Test applications in Azure environment

5. SECURITY AND COMPLIANCE (Weeks 5-7)
Objective: Ensure security and compliance
- Implement Azure Security Center
- Configure network security groups and firewalls
- Set up Azure Key Vault for secrets management
- Enable audit logging and compliance reporting
- Conduct security assessment

6. TESTING AND VALIDATION (Weeks 6-8)
Objective: Validate migration success
- Schedule production cutover window
- Execute IP repointing for DNS cutover
- Perform mock cutover rehearsal
- Validate all applications post-migration
- Document final migration status
`;

  try {
    console.log('üß™ Testing Workstream Detection...\n');
    
    // Step 1: Detect workstreams
    console.log('Step 1: Detecting workstreams...');
    const detectResponse = await fetch('/api/projects/1/analyze-workstreams', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      credentials: 'include',
      body: JSON.stringify({
        documentText: testDoc,
        filename: 'azure-migration-sow.txt'
      })
    });
    
    const detectData = await detectResponse.json();
    
    console.log('‚úÖ Workstreams detected:');
    console.log('  Count:', detectData.workstreams.length);
    console.log('  Document type:', detectData.summary.documentType);
    console.log('\nWorkstreams:');
    detectData.workstreams.forEach((ws, i) => {
      console.log(`\n${i + 1}. ${ws.name}`);
      console.log(`   Complexity: ${ws.estimatedComplexity}`);
      console.log(`   Phase: ${ws.suggestedPhase}`);
      console.log(`   Requirements: ${ws.keyRequirements.length}`);
    });
    
    // Step 2: Generate checklists
    console.log('\n\nStep 2: Generating checklists...');
    const generateResponse = await fetch('/api/projects/1/generate-workstream-checklists', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      credentials: 'include',
      body: JSON.stringify({
        workstreams: detectData.workstreams,
        documentText: testDoc
      })
    });
    
    const generateData = await generateResponse.json();
    
    console.log('‚úÖ Checklists generated:');
    console.log('  Count:', generateData.count);
    console.log('  Total items:', generateData.totalItems);
    console.log('\nChecklists:');
    generateData.checklists.forEach((c, i) => {
      const itemCount = c.checklist.sections?.reduce(
        (sum, s) => sum + (s.items?.length || 0), 0
      ) || 0;
      console.log(`\n${i + 1}. ${c.workstreamName}`);
      console.log(`   Title: ${c.checklist.title}`);
      console.log(`   Sections: ${c.checklist.sections?.length || 0}`);
      console.log(`   Items: ${itemCount}`);
    });
    
    console.log('\n‚úÖ Test complete!');
    
    return {
      workstreams: detectData.workstreams,
      checklists: generateData.checklists
    };
    
  } catch (error) {
    console.error('‚ùå Test failed:', error);
  }
}

// Run test
testWorkstreamDetection();
```

VALIDATION CHECKLIST:

After implementation, verify:
- [ ] Service file created: services/workstream-detector.js
- [ ] Two API endpoints added to server.js
- [ ] Test document returns 3-10 workstreams
- [ ] Each workstream has name, description, requirements
- [ ] Checklists generated for each workstream
- [ ] Each checklist has sections with items
- [ ] No empty checklists (all have items)
- [ ] Error handling works properly
- [ ] Console logging shows progress

COMMIT MESSAGE:
"feat(phase4-mode2): add workstream detection and checklist generation

- Create workstream-detector.js service with AI analysis
- Detect 3-10 distinct work areas from documents
- Extract key requirements per workstream
- Identify dependencies between workstreams
- Generate focused checklist per workstream (5-15 items)
- POST /api/projects/:id/analyze-workstreams endpoint
- POST /api/projects/:id/generate-workstream-checklists endpoint
- Comprehensive validation and error handling
- Test script for verification


const PDFDocument = require('pdfkit');
const streamBuffers = require('stream-buffers');

// Chart generation disabled due to system library issues
// const { ChartJSNodeCanvas } = require('chartjs-node-canvas');

/**
 * Generate PDF from checklist data
 */
async function generateChecklistPDF(checklistData, options = {}) {
  const {
    format = 'full',              // 'full', 'summary', 'completed-only'
    include_comments = true,
    include_charts = true,
    include_metadata = true
  } = options;
  
  // Create PDF document
  const doc = new PDFDocument({
    size: 'LETTER',
    margins: {
      top: 50,
      bottom: 50,
      left: 50,
      right: 50
    },
    info: {
      Title: checklistData.title,
      Author: 'Multi-Project Tracker Checklist System',
      Subject: 'Checklist Report',
      CreationDate: new Date()
    }
  });
  
  // Use stream buffer to capture PDF
  const outputBuffer = new streamBuffers.WritableStreamBuffer();
  doc.pipe(outputBuffer);
  
  try {
    // Header
    await addHeader(doc, checklistData);
    
    // Metadata section
    if (include_metadata) {
      await addMetadata(doc, checklistData);
    }
    
    // Progress chart
    if (include_charts) {
      await addProgressChart(doc, checklistData);
    }
    
    // Checklist sections and items
    await addChecklistContent(doc, checklistData, format, include_comments);
    
    // Sign-off section
    await addSignOffSection(doc, checklistData);
    
    // Add simple footer on last page
    doc.moveDown(2);
    doc.fontSize(8)
       .fillColor('#9ca3af')
       .font('Helvetica')
       .text(
         `Generated: ${formatDate(new Date())} | Multi-Project Tracker`,
         50,
         doc.page.height - 50,
         { align: 'center', width: doc.page.width - 100 }
       );
    
    // Finalize PDF
    doc.end();
    
    // Wait for PDF to finish
    await new Promise((resolve) => {
      outputBuffer.on('finish', resolve);
    });
    
    return outputBuffer.getContents();
    
  } catch (error) {
    console.error('PDF generation error:', error);
    throw new Error(`Failed to generate PDF: ${error.message}`);
  }
}

/**
 * Add header to PDF
 */
function addHeader(doc, checklistData) {
  // Title
  doc.fontSize(20)
     .fillColor('#1f2937')
     .font('Helvetica-Bold')
     .text(checklistData.title, { align: 'center' });
  
  doc.moveDown(0.5);
  
  // Subtitle with status badge
  const statusColors = {
    'not-started': '#6b7280',
    'in-progress': '#3b82f6',
    'completed': '#10b981',
    'approved': '#8b5cf6'
  };
  
  doc.fontSize(12)
     .fillColor(statusColors[checklistData.status] || '#6b7280')
     .font('Helvetica')
     .text(`Status: ${formatStatus(checklistData.status)}`, { align: 'center' });
  
  // Horizontal line
  doc.moveDown(1);
  doc.strokeColor('#e5e7eb')
     .lineWidth(1)
     .moveTo(50, doc.y)
     .lineTo(562, doc.y)
     .stroke();
  
  doc.moveDown(1);
  
  return doc;
}

/**
 * Add metadata section
 */
function addMetadata(doc, checklistData) {
  doc.fontSize(14)
     .fillColor('#1f2937')
     .font('Helvetica-Bold')
     .text('Checklist Information');
  
  doc.moveDown(0.5);
  
  // Metadata table
  const metadata = [
    { label: 'Checklist ID:', value: checklistData.id || checklistData.checklist_id },
    { label: 'Project:', value: checklistData.project_name },
    { label: 'Template:', value: checklistData.template_name },
    { label: 'Created By:', value: checklistData.created_by_name },
    { label: 'Created On:', value: formatDate(checklistData.created_at) },
    { label: 'Last Updated:', value: formatDate(checklistData.updated_at) },
    { label: 'Total Items:', value: checklistData.total_items },
    { label: 'Completed Items:', value: checklistData.completed_items },
    { label: 'Completion:', value: `${checklistData.completion_percentage}%` }
  ];
  
  // Add AI generation info if applicable
  if (checklistData.is_ai_generated) {
    metadata.push({
      label: 'Generated By:',
      value: `AI from ${checklistData.generation_source === 'issue' ? 'Issue' : 'Action Item'}`
    });
    
    if (checklistData.source_title) {
      metadata.push({
        label: 'Source:',
        value: checklistData.source_title
      });
    }
  }
  
  doc.fontSize(10)
     .fillColor('#374151')
     .font('Helvetica');
  
  metadata.forEach(item => {
    doc.font('Helvetica-Bold').text(item.label, 70, doc.y, { continued: true, width: 150 });
    doc.font('Helvetica').text(item.value, { width: 350 });
    doc.moveDown(0.3);
  });
  
  doc.moveDown(1);
  
  return doc;
}

/**
 * Add progress chart (text-based progress bar)
 */
async function addProgressChart(doc, checklistData) {
  try {
    const completed = checklistData.completed_items || 0;
    const total = checklistData.total_items || 0;
    const percentage = total > 0 ? Math.round((completed / total) * 100) : 0;
    
    // Add section title
    doc.fontSize(14)
       .fillColor('#1f2937')
       .font('Helvetica-Bold')
       .text('Progress Overview', { align: 'center' });
    
    doc.moveDown(0.5);
    
    // Add progress stats
    doc.fontSize(12)
       .fillColor('#374151')
       .font('Helvetica')
       .text(`${completed} of ${total} items completed (${percentage}%)`, { align: 'center' });
    
    doc.moveDown(0.8);
    
    // Draw progress bar
    const barWidth = 400;
    const barHeight = 30;
    const startX = (doc.page.width - barWidth) / 2;
    const startY = doc.y;
    
    // Background (light gray)
    doc.rect(startX, startY, barWidth, barHeight)
       .fillAndStroke('#e5e7eb', '#d1d5db');
    
    // Completed portion (green)
    if (completed > 0) {
      const completedWidth = (completed / total) * barWidth;
      doc.rect(startX, startY, completedWidth, barHeight)
         .fillAndStroke('#10b981', '#059669');
    }
    
    // Percentage text on bar
    doc.fontSize(12)
       .fillColor('#ffffff')
       .font('Helvetica-Bold')
       .text(`${percentage}%`, startX, startY + 8, {
         width: barWidth,
         align: 'center'
       });
    
    doc.moveDown(3);
    
  } catch (error) {
    console.error('Progress bar generation error:', error);
    // Continue without progress visualization
    doc.fontSize(10)
       .fillColor('#6b7280')
       .text('Progress data unavailable', { align: 'center' });
    doc.moveDown(1);
  }
  
  return doc;
}

/**
 * Add checklist content (sections and items)
 */
async function addChecklistContent(doc, checklistData, format, includeComments) {
  doc.fontSize(14)
     .fillColor('#1f2937')
     .font('Helvetica-Bold')
     .text('Checklist Items');
  
  doc.moveDown(1);
  
  // Group items by section
  const sections = {};
  checklistData.items.forEach(item => {
    if (!sections[item.section_title]) {
      sections[item.section_title] = [];
    }
    sections[item.section_title].push(item);
  });
  
  // Iterate through sections
  for (const [sectionTitle, items] of Object.entries(sections)) {
    // Check if we need a new page
    if (doc.y > 650) {
      doc.addPage();
    }
    
    // Section header
    doc.fontSize(12)
       .fillColor('#1f2937')
       .font('Helvetica-Bold')
       .text(sectionTitle);
    
    doc.moveDown(0.5);
    
    // Items in section
    for (const item of items) {
      // Skip non-completed items if format is 'completed-only'
      if (format === 'completed-only' && !item.response_value) {
        continue;
      }
      
      // Check page space
      if (doc.y > 700) {
        doc.addPage();
      }
      
      // Item checkbox/bullet
      const isCompleted = !!item.response_value;
      const symbol = isCompleted ? '☑' : '☐';
      
      doc.fontSize(10)
         .fillColor('#374151')
         .font('Helvetica');
      
      // Item text with checkbox
      const itemY = doc.y;
      doc.text(symbol, 70, itemY, { continued: true, width: 15 });
      doc.text(item.item_text || item.text, { width: 450 });
      
      // Response value if exists
      if (item.response_value) {
        doc.moveDown(0.2);
        doc.fontSize(9)
           .fillColor('#6b7280')
           .font('Helvetica');
        
        const responseLabel = getFieldTypeLabel(item.field_type);
        doc.text(`${responseLabel}: ${formatResponseValue(item.response_value, item.field_type)}`, 85, doc.y);
      }
      
      // Comments if exist and included
      if (includeComments && item.comments && item.comments.length > 0) {
        doc.moveDown(0.2);
        doc.fontSize(8)
           .fillColor('#9ca3af')
           .font('Helvetica-Oblique')
           .text(`💬 ${item.comments.length} comment(s)`, 85, doc.y);
      }
      
      doc.moveDown(0.5);
    }
    
    doc.moveDown(0.5);
  }
  
  return doc;
}

/**
 * Add sign-off section
 */
function addSignOffSection(doc, checklistData) {
  // New page for sign-offs
  doc.addPage();
  
  doc.fontSize(14)
     .fillColor('#1f2937')
     .font('Helvetica-Bold')
     .text('Sign-Off & Approval');
  
  doc.moveDown(1);
  
  if (checklistData.signoffs && checklistData.signoffs.length > 0) {
    checklistData.signoffs.forEach(signoff => {
      // Sign-off box
      doc.rect(70, doc.y, 470, 100)
         .stroke('#e5e7eb');
      
      const boxY = doc.y;
      
      doc.fontSize(11)
         .fillColor('#1f2937')
         .font('Helvetica-Bold')
         .text(signoff.role, 80, boxY + 10);
      
      doc.fontSize(10)
         .fillColor('#374151')
         .font('Helvetica')
         .text(`Name: ${signoff.signed_by_name}`, 80, boxY + 30)
         .text(`Date: ${formatDate(signoff.signed_at)}`, 80, boxY + 45);
      
      if (signoff.status === 'approved') {
        doc.fillColor('#10b981')
           .text('✓ APPROVED', 400, boxY + 30);
      } else if (signoff.status === 'rejected') {
        doc.fillColor('#ef4444')
           .text('✗ REJECTED', 400, boxY + 30);
      }
      
      if (signoff.comments) {
        doc.fontSize(9)
           .fillColor('#6b7280')
           .text(`Comments: ${signoff.comments}`, 80, boxY + 65, { width: 450 });
      }
      
      doc.moveDown(7);
    });
  } else {
    // Placeholder for sign-offs
    doc.fontSize(10)
       .fillColor('#6b7280')
       .font('Helvetica')
       .text('No sign-offs recorded yet.', { align: 'center' });
    
    doc.moveDown(2);
    
    // Signature lines
    ['Technical Reviewer', 'Project Manager', 'Client Approval'].forEach((role, idx) => {
      const y = doc.y + (idx * 80);
      
      doc.fontSize(10)
         .fillColor('#374151')
         .font('Helvetica-Bold')
         .text(role, 70, y);
      
      // Signature line
      doc.moveTo(70, y + 40)
         .lineTo(270, y + 40)
         .stroke('#9ca3af');
      
      doc.fontSize(8)
         .fillColor('#9ca3af')
         .font('Helvetica')
         .text('Signature', 70, y + 45);
      
      // Date line
      doc.moveTo(320, y + 40)
         .lineTo(470, y + 40)
         .stroke('#9ca3af');
      
      doc.text('Date', 320, y + 45);
    });
  }
  
  return doc;
}

/**
 * Add page numbers
 */
function addPageNumbers(doc) {
  const pages = doc.bufferedPageRange();
  
  for (let i = 0; i < pages.count; i++) {
    doc.switchToPage(i);
    
    // Footer text
    doc.fontSize(8)
       .fillColor('#9ca3af')
       .font('Helvetica')
       .text(
         `Page ${i + 1} of ${pages.count} | Generated: ${formatDate(new Date())}`,
         50,
         doc.page.height - 40,
         { align: 'center', width: doc.page.width - 100 }
       );
  }
}

/**
 * Helper: Format status
 */
function formatStatus(status) {
  const statusMap = {
    'not-started': 'Not Started',
    'in-progress': 'In Progress',
    'completed': 'Completed',
    'approved': 'Approved'
  };
  return statusMap[status] || status;
}

/**
 * Helper: Format date
 */
function formatDate(date) {
  if (!date) return 'N/A';
  const d = new Date(date);
  return d.toLocaleDateString('en-US', { 
    year: 'numeric', 
    month: 'long', 
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit'
  });
}

/**
 * Helper: Get field type label
 */
function getFieldTypeLabel(fieldType) {
  const labels = {
    'checkbox': 'Checked',
    'text': 'Response',
    'textarea': 'Notes',
    'date': 'Date',
    'radio': 'Selection',
    'dropdown': 'Selection'
  };
  return labels[fieldType] || 'Value';
}

/**
 * Helper: Format response value
 */
function formatResponseValue(value, fieldType) {
  if (!value) return 'N/A';
  
  if (fieldType === 'checkbox') {
    return value === 'true' || value === true ? 'Yes' : 'No';
  }
  
  if (fieldType === 'date') {
    try {
      return new Date(value).toLocaleDateString('en-US');
    } catch (e) {
      return value;
    }
  }
  
  // Truncate long text
  if (typeof value === 'string' && value.length > 100) {
    return value.substring(0, 100) + '...';
  }
  
  return value;
}

module.exports = {
  generateChecklistPDF
};

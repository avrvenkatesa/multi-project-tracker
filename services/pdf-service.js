const PDFDocument = require('pdfkit');

/**
 * Generate PDF from checklist data (using same approach as dashboard reports)
 */
async function generateChecklistPDF(checklistData, options = {}) {
  const {
    format = 'full',              // 'full', 'summary', 'completed-only'
    include_comments = true,
    include_charts = true,
    include_metadata = true
  } = options;
  
  return new Promise(async (resolve, reject) => {
    try {
      // Create PDF document with same settings as dashboard reports
      const doc = new PDFDocument({ 
        size: 'A4', 
        margin: 50,
        info: {
          Title: checklistData.title || 'Checklist Report',
          Author: 'Multi-Project Tracker System',
          Subject: `Project Checklist Report`,
          Keywords: 'checklist, report, compliance, verification, project',
          Creator: 'Multi-Project Tracker v1.0',
          Producer: 'PDFKit Library',
          CreationDate: new Date(),
          ModDate: new Date()
        }
      });
      
      const chunks = [];
      
      doc.on('data', chunk => chunks.push(chunk));
      doc.on('end', () => resolve(Buffer.concat(chunks)));
      doc.on('error', reject);
      
      // Header
      await addHeader(doc, checklistData);
      
      // Metadata section
      if (include_metadata) {
        await addMetadata(doc, checklistData);
      }
      
      // Progress chart
      if (include_charts) {
        await addProgressChart(doc, checklistData);
      }
      
      // Checklist sections and items
      await addChecklistContent(doc, checklistData, format, include_comments);
      
      // Sign-off section
      await addSignOffSection(doc, checklistData);
      
      // Add page numbers to all pages
      const range = doc.bufferedPageRange();
      const pageCount = range.count;
      
      for (let i = 0; i < pageCount; i++) {
        doc.switchToPage(range.start + i);
        doc.fontSize(9).fillColor('#666666').font('Helvetica').text(
          `Page ${range.start + i + 1} of ${range.start + pageCount}`,
          50,
          doc.page.height - 50,
          { align: 'center' }
        );
      }
      
      doc.end();
      
    } catch (error) {
      console.error('PDF generation error:', error);
      reject(new Error(`Failed to generate PDF: ${error.message}`));
    }
  });
}

/**
 * Add header to PDF
 */
function addHeader(doc, checklistData) {
  // Title
  doc.fontSize(20)
     .fillColor('#1f2937')
     .font('Helvetica-Bold')
     .text(checklistData.title, { align: 'center' });
  
  doc.moveDown(0.5);
  
  // Subtitle with status badge
  const statusColors = {
    'not-started': '#6b7280',
    'in-progress': '#3b82f6',
    'completed': '#10b981',
    'approved': '#8b5cf6'
  };
  
  doc.fontSize(12)
     .fillColor(statusColors[checklistData.status] || '#6b7280')
     .font('Helvetica')
     .text(`Status: ${formatStatus(checklistData.status)}`, { align: 'center' });
  
  // Horizontal line
  doc.moveDown(1);
  doc.strokeColor('#e5e7eb')
     .lineWidth(1)
     .moveTo(50, doc.y)
     .lineTo(562, doc.y)
     .stroke();
  
  doc.moveDown(1);
  
  return doc;
}

/**
 * Add metadata section
 */
function addMetadata(doc, checklistData) {
  doc.fontSize(14)
     .fillColor('#1f2937')
     .font('Helvetica-Bold')
     .text('Checklist Information');
  
  doc.moveDown(0.5);
  
  // Metadata table
  const metadata = [
    { label: 'Checklist ID:', value: checklistData.id || checklistData.checklist_id },
    { label: 'Project:', value: checklistData.project_name },
    { label: 'Template:', value: checklistData.template_name },
    { label: 'Created By:', value: checklistData.created_by_name },
    { label: 'Created On:', value: formatDate(checklistData.created_at) },
    { label: 'Last Updated:', value: formatDate(checklistData.updated_at) },
    { label: 'Total Items:', value: checklistData.total_items },
    { label: 'Completed Items:', value: checklistData.completed_items },
    { label: 'Completion:', value: `${checklistData.completion_percentage}%` }
  ];
  
  // Add AI generation info if applicable
  if (checklistData.is_ai_generated) {
    metadata.push({
      label: 'Generated By:',
      value: `AI from ${checklistData.generation_source === 'issue' ? 'Issue' : 'Action Item'}`
    });
    
    if (checklistData.source_title) {
      metadata.push({
        label: 'Source:',
        value: checklistData.source_title
      });
    }
  }
  
  doc.fontSize(10)
     .fillColor('#374151')
     .font('Helvetica');
  
  metadata.forEach(item => {
    const currentY = doc.y;
    doc.font('Helvetica-Bold').text(item.label, 70, currentY, { width: 150 });
    doc.font('Helvetica').text(item.value, 230, currentY, { width: 300 });
    doc.moveDown(0.8);
  });
  
  doc.moveDown(1);
  
  return doc;
}

/**
 * Add progress chart (text-based progress bar)
 */
async function addProgressChart(doc, checklistData) {
  try {
    const completed = checklistData.completed_items || 0;
    const total = checklistData.total_items || 0;
    const percentage = total > 0 ? Math.round((completed / total) * 100) : 0;
    
    // Add section title
    doc.fontSize(14)
       .fillColor('#1f2937')
       .font('Helvetica-Bold')
       .text('Progress Overview', { align: 'center' });
    
    doc.moveDown(0.5);
    
    // Add progress stats
    doc.fontSize(12)
       .fillColor('#374151')
       .font('Helvetica')
       .text(`${completed} of ${total} items completed (${percentage}%)`, { align: 'center' });
    
    doc.moveDown(0.8);
    
    // Draw progress bar
    const barWidth = 400;
    const barHeight = 30;
    const startX = (doc.page.width - barWidth) / 2;
    const startY = doc.y;
    
    // Background (light gray)
    doc.rect(startX, startY, barWidth, barHeight)
       .fillAndStroke('#e5e7eb', '#d1d5db');
    
    // Completed portion (green)
    if (completed > 0) {
      const completedWidth = (completed / total) * barWidth;
      doc.rect(startX, startY, completedWidth, barHeight)
         .fillAndStroke('#10b981', '#059669');
    }
    
    // Percentage text on bar
    doc.fontSize(12)
       .fillColor('#ffffff')
       .font('Helvetica-Bold')
       .text(`${percentage}%`, startX, startY + 8, {
         width: barWidth,
         align: 'center'
       });
    
    doc.moveDown(3);
    
  } catch (error) {
    console.error('Progress bar generation error:', error);
    // Continue without progress visualization
    doc.fontSize(10)
       .fillColor('#6b7280')
       .text('Progress data unavailable', { align: 'center' });
    doc.moveDown(1);
  }
  
  return doc;
}

/**
 * Add checklist content (sections and items)
 */
async function addChecklistContent(doc, checklistData, format, includeComments) {
  doc.fontSize(14)
     .fillColor('#1f2937')
     .font('Helvetica-Bold')
     .text('Checklist Items');
  
  doc.moveDown(1);
  
  // Group items by section
  const sections = {};
  checklistData.items.forEach(item => {
    if (!sections[item.section_title]) {
      sections[item.section_title] = [];
    }
    sections[item.section_title].push(item);
  });
  
  // Iterate through sections
  for (const [sectionTitle, items] of Object.entries(sections)) {
    // Check if we need a new page
    if (doc.y > 650) {
      doc.addPage();
    }
    
    // Section header
    doc.fontSize(12)
       .fillColor('#1f2937')
       .font('Helvetica-Bold')
       .text(sectionTitle);
    
    doc.moveDown(0.5);
    
    // Items in section
    for (const item of items) {
      // Skip non-completed items if format is 'completed-only'
      if (format === 'completed-only' && !item.is_completed) {
        continue;
      }
      
      // Check page space
      if (doc.y > 700) {
        doc.addPage();
      }
      
      // Item checkbox/bullet (using safe ASCII characters)
      const isCompleted = !!item.is_completed;
      const symbol = isCompleted ? '[X]' : '[ ]';
      
      doc.fontSize(10)
         .fillColor('#374151')
         .font('Helvetica');
      
      // Item text with checkbox (fixed wrapping)
      const itemY = doc.y;
      doc.text(symbol, 70, itemY);
      doc.text(item.item_text || item.text, 95, itemY, { width: 445 });
      
      // Display response based on field type
      // For checkboxes: [X] or [ ] symbol is enough, only show notes if present
      // For dates: show the date
      // For text fields: show the text value
      
      if (item.field_type === 'date' && item.response_date) {
        // Show date response
        doc.moveDown(0.2);
        doc.fontSize(9)
           .fillColor('#6b7280')
           .font('Helvetica');
        doc.text(`Date: ${formatResponseValue(item.response_date, 'date')}`, 85, doc.y);
      } else if (item.field_type === 'text' && item.response_value) {
        // Show text response
        doc.moveDown(0.2);
        doc.fontSize(9)
           .fillColor('#6b7280')
           .font('Helvetica');
        doc.text(`Response: ${item.response_value}`, 85, doc.y, { width: 450 });
      }
      
      // Show notes if they exist (separate from the checkbox/date/text response)
      if (item.notes && item.notes.trim() !== '') {
        doc.moveDown(0.2);
        doc.fontSize(9)
           .fillColor('#6b7280')
           .font('Helvetica');
        doc.text(`Notes: ${item.notes}`, 85, doc.y, { width: 450 });
      }
      
      // Comments if exist and included
      if (includeComments && item.comments && item.comments.length > 0) {
        doc.moveDown(0.2);
        doc.fontSize(8)
           .fillColor('#9ca3af')
           .font('Helvetica-Oblique')
           .text(`Comments: ${item.comments.length}`, 85, doc.y);
      }
      
      doc.moveDown(0.5);
    }
    
    doc.moveDown(0.5);
  }
  
  return doc;
}

/**
 * Add sign-off section
 */
function addSignOffSection(doc, checklistData) {
  // New page for sign-offs
  doc.addPage();
  
  doc.fontSize(14)
     .fillColor('#1f2937')
     .font('Helvetica-Bold')
     .text('Sign-Off & Approval');
  
  doc.moveDown(1);
  
  if (checklistData.signoffs && checklistData.signoffs.length > 0) {
    checklistData.signoffs.forEach(signoff => {
      // Sign-off box
      doc.rect(70, doc.y, 470, 100)
         .stroke('#e5e7eb');
      
      const boxY = doc.y;
      
      doc.fontSize(11)
         .fillColor('#1f2937')
         .font('Helvetica-Bold')
         .text(signoff.role, 80, boxY + 10);
      
      doc.fontSize(10)
         .fillColor('#374151')
         .font('Helvetica')
         .text(`Name: ${signoff.signed_by_name}`, 80, boxY + 30)
         .text(`Date: ${formatDate(signoff.signed_at)}`, 80, boxY + 45);
      
      if (signoff.status === 'approved') {
        doc.fillColor('#10b981')
           .text('✓ APPROVED', 400, boxY + 30);
      } else if (signoff.status === 'rejected') {
        doc.fillColor('#ef4444')
           .text('✗ REJECTED', 400, boxY + 30);
      }
      
      if (signoff.comments) {
        doc.fontSize(9)
           .fillColor('#6b7280')
           .text(`Comments: ${signoff.comments}`, 80, boxY + 65, { width: 450 });
      }
      
      doc.moveDown(7);
    });
  } else {
    // Placeholder for sign-offs
    doc.fontSize(10)
       .fillColor('#6b7280')
       .font('Helvetica')
       .text('No sign-offs recorded yet.', { align: 'center' });
    
    doc.moveDown(2);
    
    // Signature lines
    ['Technical Reviewer', 'Project Manager', 'Client Approval'].forEach((role, idx) => {
      const y = doc.y + (idx * 80);
      
      doc.fontSize(10)
         .fillColor('#374151')
         .font('Helvetica-Bold')
         .text(role, 70, y);
      
      // Signature line
      doc.moveTo(70, y + 40)
         .lineTo(270, y + 40)
         .stroke('#9ca3af');
      
      doc.fontSize(8)
         .fillColor('#9ca3af')
         .font('Helvetica')
         .text('Signature', 70, y + 45);
      
      // Date line
      doc.moveTo(320, y + 40)
         .lineTo(470, y + 40)
         .stroke('#9ca3af');
      
      doc.text('Date', 320, y + 45);
    });
  }
  
  return doc;
}

/**
 * Add page numbers
 */
function addPageNumbers(doc) {
  const pages = doc.bufferedPageRange();
  
  for (let i = 0; i < pages.count; i++) {
    doc.switchToPage(i);
    
    // Footer text
    doc.fontSize(8)
       .fillColor('#9ca3af')
       .font('Helvetica')
       .text(
         `Page ${i + 1} of ${pages.count} | Generated: ${formatDate(new Date())}`,
         50,
         doc.page.height - 40,
         { align: 'center', width: doc.page.width - 100 }
       );
  }
}

/**
 * Helper: Format status
 */
function formatStatus(status) {
  const statusMap = {
    'not-started': 'Not Started',
    'in-progress': 'In Progress',
    'completed': 'Completed',
    'approved': 'Approved'
  };
  return statusMap[status] || status;
}

/**
 * Helper: Format date
 */
function formatDate(date) {
  if (!date) return 'N/A';
  const d = new Date(date);
  return d.toLocaleDateString('en-US', { 
    year: 'numeric', 
    month: 'long', 
    day: 'numeric',
    hour: '2-digit',
    minute: '2-digit'
  });
}

/**
 * Helper: Get field type label
 */
function getFieldTypeLabel(fieldType) {
  const labels = {
    'checkbox': 'Checked',
    'text': 'Response',
    'textarea': 'Notes',
    'date': 'Date',
    'radio': 'Selection',
    'dropdown': 'Selection'
  };
  return labels[fieldType] || 'Value';
}

/**
 * Helper: Format response value
 */
function formatResponseValue(value, fieldType) {
  if (!value) return 'N/A';
  
  if (fieldType === 'checkbox') {
    return value === 'true' || value === true ? 'Yes' : 'No';
  }
  
  if (fieldType === 'date') {
    try {
      return new Date(value).toLocaleDateString('en-US');
    } catch (e) {
      return value;
    }
  }
  
  // Truncate long text
  if (typeof value === 'string' && value.length > 100) {
    return value.substring(0, 100) + '...';
  }
  
  return value;
}

/**
 * Generate PDF report for project schedule
 * Includes timeline, Gantt visualization, and resources
 */
async function generateSchedulePDF(scheduleData) {
  return new Promise(async (resolve, reject) => {
    try {
      const { schedule, tasks, resources } = scheduleData;
      
      const doc = new PDFDocument({ 
        size: 'A4', 
        margin: 40,
        info: {
          Title: `Schedule: ${schedule.name}`,
          Author: 'Multi-Project Tracker System',
          Subject: `Project Schedule Report`,
          Keywords: 'schedule, timeline, gantt, resources, project',
          Creator: 'Multi-Project Tracker v1.0',
          Producer: 'PDFKit Library',
          CreationDate: new Date(),
          ModDate: new Date()
        }
      });
      
      const chunks = [];
      
      doc.on('data', chunk => chunks.push(chunk));
      doc.on('end', () => resolve(Buffer.concat(chunks)));
      doc.on('error', reject);
      
      // Title page
      doc.fontSize(24).font('Helvetica-Bold').fillColor('#1e40af')
        .text('Project Schedule Report', { align: 'center' });
      
      doc.moveDown(0.5);
      doc.fontSize(18).fillColor('#1f2937')
        .text(schedule.name, { align: 'center' });
      
      doc.moveDown(1);
      
      // Schedule Summary
      addScheduleSummary(doc, schedule);
      
      doc.addPage();
      
      // Timeline section
      addTimelineSection(doc, tasks);
      
      doc.addPage();
      
      // Gantt visualization
      addGanttVisualization(doc, tasks, schedule);
      
      doc.addPage();
      
      // Resources section
      addResourcesSection(doc, resources, schedule);
      
      // Add page numbers
      const range = doc.bufferedPageRange();
      const pageCount = range.count;
      
      for (let i = 0; i < pageCount; i++) {
        doc.switchToPage(range.start + i);
        doc.fontSize(9).fillColor('#666666').font('Helvetica').text(
          `Page ${range.start + i + 1} of ${range.start + pageCount}`,
          40,
          doc.page.height - 40,
          { align: 'center' }
        );
      }
      
      doc.end();
      
    } catch (error) {
      console.error('Schedule PDF generation error:', error);
      reject(new Error(`Failed to generate schedule PDF: ${error.message}`));
    }
  });
}

function addScheduleSummary(doc, schedule) {
  doc.fontSize(16).font('Helvetica-Bold').fillColor('#1f2937')
    .text('Schedule Summary', 40, doc.y);
  
  doc.moveDown(0.5);
  
  const summaryY = doc.y;
  const boxHeight = 120;
  
  // Draw background boxes
  doc.rect(40, summaryY, 250, boxHeight).fillAndStroke('#f3f4f6', '#d1d5db');
  doc.rect(300, summaryY, 250, boxHeight).fillAndStroke('#f3f4f6', '#d1d5db');
  
  // Left column
  doc.fontSize(11).font('Helvetica-Bold').fillColor('#4b5563')
    .text('DURATION', 50, summaryY + 10);
  doc.fontSize(18).font('Helvetica-Bold').fillColor('#1f2937')
    .text(`${schedule.total_days || 0} days`, 50, summaryY + 30);
  const startDate = new Date(schedule.start_date).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
  const endDate = new Date(schedule.end_date).toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
  doc.fontSize(9).fillColor('#6b7280')
    .text(`${startDate} - ${endDate}`, 50, summaryY + 55);
  
  doc.fontSize(11).font('Helvetica-Bold').fillColor('#4b5563')
    .text('TOTAL TASKS', 50, summaryY + 75);
  doc.fontSize(18).font('Helvetica-Bold').fillColor('#1f2937')
    .text(`${schedule.total_tasks || 0}`, 50, summaryY + 95);
  
  // Right column
  doc.fontSize(11).font('Helvetica-Bold').fillColor('#4b5563')
    .text('CRITICAL PATH', 310, summaryY + 10);
  doc.fontSize(18).font('Helvetica-Bold').fillColor('#dc2626')
    .text(`${schedule.critical_path_tasks || 0} tasks`, 310, summaryY + 30);
  doc.fontSize(9).fillColor('#6b7280')
    .text(`${schedule.critical_path_hours || 0} hours`, 310, summaryY + 55);
  
  doc.fontSize(11).font('Helvetica-Bold').fillColor('#4b5563')
    .text('RISKS', 310, summaryY + 75);
  const riskColor = (schedule.risks_count || 0) > 0 ? '#dc2626' : '#059669';
  doc.fontSize(18).font('Helvetica-Bold').fillColor(riskColor)
    .text(`${schedule.risks_count || 0}`, 310, summaryY + 95);
  
  doc.y = summaryY + boxHeight + 15;
  
  // Work schedule info
  doc.fontSize(10).font('Helvetica').fillColor('#374151')
    .text(`Work Schedule: ${schedule.hours_per_day} hours/day, ${schedule.include_weekends ? '7 days/week (including weekends)' : 'Monday-Friday (business days only)'}`, 40, doc.y);
  
  if (schedule.notes) {
    doc.moveDown(0.5);
    doc.fontSize(10).font('Helvetica-Bold').fillColor('#4b5563')
      .text('Notes:', 40, doc.y);
    doc.fontSize(9).font('Helvetica').fillColor('#6b7280')
      .text(schedule.notes, 40, doc.y + 15, { width: 510 });
  }
}

function addTimelineSection(doc, tasks) {
  doc.fontSize(16).font('Helvetica-Bold').fillColor('#1f2937')
    .text('Timeline', 40, 40);
  
  doc.moveDown(1);
  
  const tableTop = doc.y;
  const col1X = 40;
  const col2X = 200;
  const col3X = 300;
  const col4X = 400;
  const col5X = 480;
  const rowHeight = 20;
  
  // Table header
  doc.rect(col1X, tableTop, 515, rowHeight).fillAndStroke('#1e40af', '#1e40af');
  doc.fontSize(9).font('Helvetica-Bold').fillColor('#ffffff')
    .text('Task', col1X + 5, tableTop + 6)
    .text('Start', col2X + 5, tableTop + 6)
    .text('End', col3X + 5, tableTop + 6)
    .text('Duration', col4X + 5, tableTop + 6)
    .text('Status', col5X + 5, tableTop + 6);
  
  let currentY = tableTop + rowHeight;
  
  // Table rows
  tasks.forEach((task, index) => {
    const bgColor = task.is_critical_path ? '#fee2e2' : (index % 2 === 0 ? '#ffffff' : '#f9fafb');
    doc.rect(col1X, currentY, 515, rowHeight).fillAndStroke(bgColor, '#e5e7eb');
    
    const startDate = new Date(task.scheduled_start).toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
    const endDate = new Date(task.scheduled_end).toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
    const duration = Math.ceil((new Date(task.scheduled_end) - new Date(task.scheduled_start)) / (1000 * 60 * 60 * 24));
    
    const titleColor = task.is_critical_path ? '#991b1b' : '#1f2937';
    doc.fontSize(8).font('Helvetica').fillColor(titleColor)
      .text(task.title.substring(0, 30) + (task.title.length > 30 ? '...' : ''), col1X + 5, currentY + 6, { width: 150 })
      .text(startDate, col2X + 5, currentY + 6)
      .text(endDate, col3X + 5, currentY + 6)
      .text(`${duration}d`, col4X + 5, currentY + 6)
      .text(task.status || 'To Do', col5X + 5, currentY + 6);
    
    currentY += rowHeight;
    
    // Add new page if needed
    if (currentY > doc.page.height - 80) {
      doc.addPage();
      currentY = 60;
    }
  });
}

function addGanttVisualization(doc, tasks, schedule) {
  doc.fontSize(16).font('Helvetica-Bold').fillColor('#1f2937')
    .text('Gantt Chart', 40, 40);
  
  doc.moveDown(1);
  
  const chartTop = doc.y;
  const chartLeft = 40;
  const taskNameWidth = 180;
  const timelineWidth = 350;
  const rowHeight = 25;
  
  // Calculate date range
  const startDate = new Date(schedule.start_date);
  const endDate = new Date(schedule.end_date);
  const totalDays = Math.ceil((endDate - startDate) / (1000 * 60 * 60 * 24));
  
  // Draw timeline header with dates
  doc.fontSize(8).font('Helvetica-Bold').fillColor('#4b5563');
  const headerIntervals = Math.min(10, totalDays);
  for (let i = 0; i <= headerIntervals; i++) {
    const intervalDate = new Date(startDate);
    intervalDate.setDate(startDate.getDate() + Math.floor((totalDays / headerIntervals) * i));
    const dateStr = intervalDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
    doc.text(dateStr, chartLeft + taskNameWidth + (timelineWidth / headerIntervals) * i, chartTop - 5, { width: 50, align: 'center' });
  }
  
  let currentY = chartTop + 10;
  
  // Draw tasks
  tasks.forEach((task, index) => {
    // Task name
    const textColor = task.is_critical_path ? '#991b1b' : '#1f2937';
    doc.fontSize(8).font('Helvetica').fillColor(textColor)
      .text(task.title.substring(0, 30) + (task.title.length > 30 ? '...' : ''), chartLeft, currentY + 8, { width: taskNameWidth - 10 });
    
    // Calculate bar position and width
    const taskStart = new Date(task.scheduled_start);
    const taskEnd = new Date(task.scheduled_end);
    const daysFromStart = Math.floor((taskStart - startDate) / (1000 * 60 * 60 * 24));
    const taskDuration = Math.ceil((taskEnd - taskStart) / (1000 * 60 * 60 * 24));
    
    const barX = chartLeft + taskNameWidth + (daysFromStart / totalDays) * timelineWidth;
    const barWidth = Math.max((taskDuration / totalDays) * timelineWidth, 3);
    
    // Draw bar
    const barColor = task.is_critical_path ? '#dc2626' : '#6b9bd1';
    doc.rect(barX, currentY + 5, barWidth, 15).fillAndStroke(barColor, barColor);
    
    // Add assignee if available
    if (task.assignee) {
      doc.fontSize(7).fillColor('#6b7280')
        .text(task.assignee.substring(0, 15), barX, currentY + 5, { width: barWidth, align: 'center' });
    }
    
    currentY += rowHeight;
    
    // Add new page if needed
    if (currentY > doc.page.height - 80) {
      doc.addPage();
      currentY = 60;
      doc.fontSize(14).font('Helvetica-Bold').fillColor('#1f2937')
        .text('Gantt Chart (continued)', 40, currentY);
      currentY += 30;
    }
  });
  
  // Legend
  doc.moveDown(2);
  const legendY = currentY + 20;
  doc.rect(chartLeft, legendY, 10, 10).fillAndStroke('#6b9bd1', '#6b9bd1');
  doc.fontSize(9).font('Helvetica').fillColor('#1f2937')
    .text('Regular Task', chartLeft + 15, legendY + 1);
  
  doc.rect(chartLeft + 120, legendY, 10, 10).fillAndStroke('#dc2626', '#dc2626');
  doc.text('Critical Path', chartLeft + 135, legendY + 1);
  
  // Add task details table
  doc.addPage();
  addTaskDetailsTable(doc, tasks, schedule);
}

function addTaskDetailsTable(doc, tasks, schedule) {
  doc.fontSize(16).font('Helvetica-Bold').fillColor('#1f2937')
    .text('Task Details', 40, 40);
  
  doc.moveDown(1);
  
  const tableTop = doc.y;
  const rowHeight = 18;
  const fontSize = 7;
  
  // Column positions
  const cols = {
    task: 40,
    assignee: 140,
    duration: 200,
    status: 240,
    start: 300,
    end: 360,
    hours: 420,
    critical: 480
  };
  
  // Table header
  doc.rect(cols.task, tableTop, 515, rowHeight).fillAndStroke('#1e40af', '#1e40af');
  doc.fontSize(8).font('Helvetica-Bold').fillColor('#ffffff')
    .text('Task', cols.task + 3, tableTop + 5)
    .text('Assignee', cols.assignee + 3, tableTop + 5)
    .text('Duration', cols.duration + 3, tableTop + 5)
    .text('Status', cols.status + 3, tableTop + 5)
    .text('Start Date', cols.start + 3, tableTop + 5)
    .text('End Date', cols.end + 3, tableTop + 5)
    .text('Hours', cols.hours + 3, tableTop + 5)
    .text('Critical', cols.critical + 3, tableTop + 5);
  
  let currentY = tableTop + rowHeight;
  
  // Table rows
  tasks.forEach((task, index) => {
    // Check if we need a new page
    if (currentY > doc.page.height - 80) {
      doc.addPage();
      currentY = 60;
      
      // Redraw header on new page
      doc.rect(cols.task, currentY, 515, rowHeight).fillAndStroke('#1e40af', '#1e40af');
      doc.fontSize(8).font('Helvetica-Bold').fillColor('#ffffff')
        .text('Task', cols.task + 3, currentY + 5)
        .text('Assignee', cols.assignee + 3, currentY + 5)
        .text('Duration', cols.duration + 3, currentY + 5)
        .text('Status', cols.status + 3, currentY + 5)
        .text('Start Date', cols.start + 3, currentY + 5)
        .text('End Date', cols.end + 3, currentY + 5)
        .text('Hours', cols.hours + 3, currentY + 5)
        .text('Critical', cols.critical + 3, currentY + 5);
      currentY += rowHeight;
    }
    
    const bgColor = task.is_critical_path ? '#fee2e2' : (index % 2 === 0 ? '#ffffff' : '#f9fafb');
    doc.rect(cols.task, currentY, 515, rowHeight).fillAndStroke(bgColor, '#e5e7eb');
    
    const startDate = new Date(task.scheduled_start).toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
    const endDate = new Date(task.scheduled_end).toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
    const duration = Math.ceil((new Date(task.scheduled_end) - new Date(task.scheduled_start)) / (1000 * 60 * 60 * 24));
    
    const textColor = task.is_critical_path ? '#991b1b' : '#1f2937';
    
    doc.fontSize(fontSize).font('Helvetica').fillColor(textColor)
      .text(task.title.substring(0, 22) + (task.title.length > 22 ? '...' : ''), cols.task + 3, currentY + 5, { width: 95 })
      .text(task.assignee ? task.assignee.substring(0, 12) : 'Unassigned', cols.assignee + 3, currentY + 5, { width: 55 })
      .text(`${duration}d`, cols.duration + 3, currentY + 5)
      .text(task.status || 'To Do', cols.status + 3, currentY + 5, { width: 55 })
      .text(startDate, cols.start + 3, currentY + 5)
      .text(endDate, cols.end + 3, currentY + 5)
      .text(`${task.estimated_hours || 0}h`, cols.hours + 3, currentY + 5);
    
    if (task.is_critical_path) {
      doc.fontSize(fontSize).font('Helvetica-Bold').fillColor('#dc2626')
        .text('⚠ Yes', cols.critical + 3, currentY + 5);
    } else {
      doc.fillColor('#9ca3af')
        .text('No', cols.critical + 3, currentY + 5);
    }
    
    currentY += rowHeight;
  });
}

function addResourcesSection(doc, resources, schedule) {
  doc.fontSize(16).font('Helvetica-Bold').fillColor('#1f2937')
    .text('Resource Workload Analysis', 40, 40);
  
  doc.moveDown(1);
  
  if (!resources || resources.length === 0) {
    doc.fontSize(10).font('Helvetica').fillColor('#6b7280')
      .text('No resource assignments found.', 40, doc.y);
    return;
  }
  
  const hoursPerDay = schedule.hours_per_day || 8;
  
  resources.forEach((resource, index) => {
    const boxY = doc.y;
    const boxHeight = 90;
    
    // Resource box
    const bgColor = resource.isOverloaded ? '#fee2e2' : '#f3f4f6';
    const borderColor = resource.isOverloaded ? '#dc2626' : '#d1d5db';
    doc.rect(40, boxY, 510, boxHeight).fillAndStroke(bgColor, borderColor);
    
    // Resource name
    doc.fontSize(12).font('Helvetica-Bold').fillColor('#1f2937')
      .text(resource.name, 50, boxY + 10);
    
    if (resource.isOverloaded) {
      doc.fontSize(8).font('Helvetica-Bold').fillColor('#dc2626')
        .text('⚠ OVERLOADED', 450, boxY + 12);
    }
    
    // Metrics
    const metricsY = boxY + 35;
    doc.fontSize(9).font('Helvetica-Bold').fillColor('#4b5563')
      .text('Tasks', 50, metricsY)
      .text('Total Hours', 150, metricsY)
      .text('Peak Daily', 250, metricsY)
      .text('Utilization', 350, metricsY)
      .text('Overloaded Days', 450, metricsY);
    
    doc.fontSize(14).font('Helvetica-Bold').fillColor('#1f2937')
      .text(resource.taskCount.toString(), 50, metricsY + 15)
      .text(`${resource.totalHours.toFixed(1)}h`, 150, metricsY + 15)
      .text(`${resource.maxDailyHours.toFixed(1)}h`, 250, metricsY + 15);
    
    const utilizationColor = resource.utilizationPercent > 100 ? '#dc2626' : '#1f2937';
    doc.fillColor(utilizationColor)
      .text(`${resource.utilizationPercent}%`, 350, metricsY + 15);
    
    const overloadColor = resource.overloadedDays > 0 ? '#dc2626' : '#059669';
    doc.fillColor(overloadColor)
      .text(resource.overloadedDays.toString(), 450, metricsY + 15);
    
    // Warning message
    if (resource.isOverloaded) {
      doc.fontSize(8).font('Helvetica').fillColor('#991b1b')
        .text(`This resource exceeds ${hoursPerDay}h/day capacity on ${resource.overloadedDays} day${resource.overloadedDays !== 1 ? 's' : ''}.`, 
          50, boxY + 70, { width: 500 });
    }
    
    doc.y = boxY + boxHeight + 15;
    
    // Add new page if needed
    if (doc.y > doc.page.height - 120) {
      doc.addPage();
      doc.y = 60;
    }
  });
}

module.exports = {
  generateChecklistPDF,
  generateSchedulePDF
};
